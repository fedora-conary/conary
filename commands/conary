#!/usr/bin/env python2.4
# -*- mode: python -*-
#
# Copyright (c) 2004-2007 rPath, Inc.
#
# This program is distributed under the terms of the Common Public License,
# version 1.0. A copy of this license should have been distributed with this
# source file in a file called LICENSE. If it is not present, the license
# is always available at http://www.rpath.com/permanent/licenses/CPL-1.0.
#
# This program is distributed in the hope that it will be useful, but
# without any warranty; without even the implied warranty of merchantability
# or fitness for a particular purpose. See the Common Public License for
# full details.
#
"""
The conary main program.
"""

import inspect
import sys
if sys.version_info < (2, 4):
    print "error: python 2.4 or later is requried"
    sys.exit(1)

if __name__ == "__main__":
    # ondemand importing for conary command line tool 
    # - but don't impose it on others!  They can load it on their own if they
    # want.
    if '--debug-all' not in sys.argv:
        from conary.lib import importer
        importer.install()

#stdlib
import itertools
import optparse
import os
import pwd
import xmlrpclib
import errno

#conary
import conary
from conary import callbacks, command, commit, conarycfg, constants
from conary import cscmd, deps, flavorcfg, query, repository
from conary import queryrep, conaryclient, rollbacks, showchangeset, state
from conary import trove, updatecmd, verify, versions
from conary.lib import cfg,cfgtypes,log, openpgpfile, openpgpkey, options, util
from conary.local import database
from conary.conaryclient import cmdline
from conary.repository import trovesource

sys.excepthook = util.genExcepthook(debug=True)
sys.stdout = util.FileIgnoreEpipe(sys.stdout)

def openDatabase(root, path):
    return database.Database(root, path)

(NO_PARAM,  ONE_PARAM)  = (options.NO_PARAM, options.ONE_PARAM)
(OPT_PARAM, MULT_PARAM) = (options.OPT_PARAM, options.MULT_PARAM)
(NORMAL_HELP, VERBOSE_HELP)  = (options.NORMAL_HELP, options.VERBOSE_HELP)

_commands = []
def _register(cmd):
    _commands.append(cmd)

class ConaryCommand(command.ConaryCommand):
    paramHelp = ''
    defaultGroup = 'Common Options'
    commandGroup = 'Miscellaneous Commands'

    def addConfigOptions(self, cfgMap, argDef):
        cfgMap['components'] = 'showComponents', NO_PARAM
        cfgMap['exclude-troves'] = 'excludeTroves', ONE_PARAM
        cfgMap['labels'] = 'showLabels', NO_PARAM,
        cfgMap['trust-threshold'] = 'trustThreshold', ONE_PARAM
        command.ConaryCommand.addConfigOptions(self, cfgMap, argDef)

class ChangeSetCommand(ConaryCommand):
    commands = ['changeset', 'cs' ]
    paramHelp = '''\
<pkg>[=[<oldver>--]<newver>]+ <outfile>

Creates a changeset with the specified troves and stores it in <outfile>'''
    help = 'Request a changeset from one or more Conary repositories'
    commandGroup = 'Repository Access'
    docs = {'no-recurse' : (VERBOSE_HELP, 
                            "Don't include child troves in changeset")}

    def addParameters(self, argDef):
        ConaryCommand.addParameters(self, argDef)
        argDef['no-recurse'] = NO_PARAM

    def runCommand(self, cfg, argSet, otherArgs):
        kwargs = {}

        callback = updatecmd.UpdateCallback(cfg)
        if cfg.quiet:
            callback = callbacks.UpdateCallback()
        if argSet.has_key('quiet'):
            callback = callbacks.UpdateCallback()
            del argSet['quiet']
        kwargs['callback'] = callback

        kwargs['recurse'] = not(argSet.has_key('no-recurse'))
        if not kwargs['recurse']:
            del argSet['no-recurse']

        if len(otherArgs) < 4 or argSet:
            return self.usage()

        outFile = otherArgs[-1]
        del otherArgs[-1]

        cscmd.ChangeSetCommand(cfg, otherArgs[2:], outFile, **kwargs)
_register(ChangeSetCommand)

class CommitCommand(ConaryCommand):
    commands = ['commit']
    paramHelp = "<changeset>"
    help = 'Commit a changeset to a Conary repository'
    docs = {'target-branch' : ('commit to branch BRANCH', 'BRANCH')}
    commandGroup = 'Repository Access'

    def addParameters(self, argDef):
        ConaryCommand.addParameters(self, argDef)
        argDef["target-branch"] = ONE_PARAM

    def runCommand(self, cfg, argSet, otherArgs):
        targetBranch = None
        if argSet.has_key('target-branch'):
            targetBranch  = argSet['target-branch']
            del argSet['target-branch']
        if len(otherArgs) < 3: return self.usage()
        for changeSet in otherArgs[2:]:
            commit.doCommit(cfg, changeSet, targetBranch)
_register(CommitCommand)

class EmergeCommand(ConaryCommand):
    commands = ['emerge']
    paramHelp = "<troveName>+"
    help = 'Build software from source and install it on the system'
    commandGroup = 'System Modification'

    docs = {'no-deps' : 'Do not check to see if buildreqs are installed' }

    def addParameters(self, argDef):
        ConaryCommand.addParameters(self, argDef)
        argDef["no-deps"] = NO_PARAM

    def runCommand(self, cfg, argSet, otherArgs):
        # import this late to reduce the dependency set for
        # the main conary command in the common case.  This lets
        # conary run even if, for example, libelf is missing
        try:
            from conary.build import cook
        except ImportError:
            log.error('Conary build tools not installed - cannot build packages.  Please install conary-build')
            return 1

        log.setVerbosity(log.INFO)

        if not os.getuid():
            # if we're running as root, switch to the emergeUser
            cookUser = cfg.emergeUser
            if not cookUser:
                log.error('Please set emergeUser config item before emerging')
                return 1
            try:
                info = pwd.getpwnam(cookUser)
            except KeyError:
                log.error("No user named '%s' to emerge with.  Please check "
                          "the 'emergeUser' config item." % cookUser)
                return 1
            if info.pw_dir == '/':
                log.error("The '%s' user's home directory is set to '/'.  "
                          "See http://wiki.rpath.com/wiki/Conary:Conversion for "
                          "assistance."
                          % cookUser)
                return 1
            if info.pw_uid == 0 or info.pw_gid == 0:
                log.error("The '%s' user has root privileges." % cookUser)
                return 1
            cookIds = (info.pw_uid, info.pw_gid)
            # reset the HOME environment variable, and reinterpolate
            # buildPath, lookaside, and logFile configuration variables
            # so that the correct home directory will be used.
            os.environ['HOME'] = info.pw_dir
            for cfgvar in ('buildPath', 'lookaside'):
                unexpanded = cfg[cfgvar]._getUnexpanded()
                cfg.configLine('%s %s' %(cfgvar, unexpanded))
            cfg.configLine('logFile ' +
                ':'.join(x._getUnexpanded() for x in cfg.logFile))
        else:
            cookIds = None

        ignoreDeps = argSet.pop('no-deps', False)
        if argSet: return self.usage()

        try:
            return cook.cookCommand(cfg, otherArgs[2:], False, {},
                                    emerge = True, cookIds=cookIds,
                                    ignoreDeps=ignoreDeps)
        except cook.CookError, msg:
            log.error(msg)
            return 1
_register(EmergeCommand)


class LocalChangeSetCommand(ConaryCommand):
    commands = ['localcs']
    paramHelp = "<pkgname>[=<version>][[flavor]] <outfile>"
    help = 'Create a changeset that represents local changes'
    hidden = True

    def runCommand(self, cfg, argSet, otherArgs):
        if len(otherArgs) != 4 and len(otherArgs) != 4:
            return self.usage()

        name = otherArgs[2]
        outFile = otherArgs[3]

        db = database.Database(cfg.root, cfg.dbPath)
        cscmd.LocalChangeSetCommand(db, cfg, name, outFile)
_register(LocalChangeSetCommand)


class LocalCommitCommand(ConaryCommand):
    commands = ['localcommit']
    paramHelp = "<changeset>"
    help = 'Apply a changeset generated by localcs to the system'
    commandGroup = 'System Modification'
    hidden = True
    def runCommand(self, cfg, argSet, otherArgs):
        if len(otherArgs) < 3: return self.usage()
        db = database.Database(cfg.root, cfg.dbPath)
        for changeSet in otherArgs[2:]:
            commit.doLocalCommit(db, changeSet)
_register(LocalCommitCommand)


class PinUnpinCommand(ConaryCommand):
    commands = ['pin', 'unpin']
    paramHelp = "<pkgname>[=<version>][[flavor]]*"
    hidden = True
    commandGroup = 'System Modification'
    def runCommand(self, cfg, argSet, otherArgs):
        if argSet: return self.usage()
        updatecmd.changePins(cfg, otherArgs[2:], pin = otherArgs[1] == "pin")

class PinCommand(PinUnpinCommand):
    commands = ['pin']
    help = 'Pin software on the system'
_register(PinCommand)

class UnPinCommand(PinUnpinCommand):
    commands = ['unpin']
    help = 'Unpin software on the system'
_register(UnPinCommand)

class RemoveCommand(ConaryCommand):
    commands = ['remove', 'rm']
    paramHelp = "<path>+"
    help = 'Remove a file the system and Conary control'
    commandGroup = 'System Modification'
    hidden = True

    def runCommand(self, cfg, argSet, otherArgs):
        if len(otherArgs) < 3: return self.usage()
        if argSet: return self.usage()

        client = conaryclient.ConaryClient(cfg)
        db = client.db
        log.syslog.command()

        rc = 0

        pathList = []

        for path in otherArgs[2:]:
            if not path:
                log.error("remove cannot handle an empty path")
                return 1

            if path[0] == '/':
                fullPath = util.joinPaths(cfg.root, path)
            else:
                fullPath = os.path.realpath(path)
                if fullPath.startswith(cfg.root) and cfg.root != '/':
                    # fix up the path to be relative to the root dir
                    path = fullPath[len(cfg.root):]
                    if path[0] != '/':
                        # the root ended with a /
                        path = '/' + fullPath

            pathList.append((fullPath, path))

        try:
            db.removeFiles([ x[1] for x in pathList ])
        except conary.errors.DatabaseError, e:
            log.error(str(e))
            return 1
        except OSError, e:
            log.error("cannot remove %s: %s" % (fullPath, e.strerror))
            return 1

        for (fullPath, path) in pathList:
            try:
                try:
                    os.unlink(fullPath)
                except OSError, e:
                    if e.errno != errno.ENOENT:
                        raise

                    log.warning("%s has already been removed from the "
                                "filesystem", fullPath)
            except OSError, e:
                log.error("cannot remove %s: %s" % (fullPath, e.strerror))
                rc = 1
            except Exception, e:
                log.error("cannot remove %s: %s" % (fullPath, str(e)))
                rc = 1

        log.syslog.commandComplete()
_register(RemoveCommand)

class RevertCommand(ConaryCommand):
    commands = ['revert']
    commandGroup = 'System Modification'
    help = 'Revert the journal from a failed operation.'
    def runCommand(self, cfg, argSet, otherArgs):
        if argSet or len(otherArgs) > 2: return self.usage()
        updatecmd.revert(cfg)
_register(RevertCommand)

class ListRollbackCommand(ConaryCommand):
    commands = ['rblist']
    commandGroup = 'Information Display'
    help = 'List the rollbacks available in the rollback stack'
    def runCommand(self, cfg, argSet, otherArgs):
        if argSet or len(otherArgs) > 2: return self.usage()
        db = openDatabase(cfg.root, cfg.dbPath)
        rollbacks.listRollbacks(db, cfg)
_register(ListRollbackCommand)

class RollbackCommand(ConaryCommand):
    commands = ['rollback', 'rb']
    paramHelp = "<rollback>"
    help = 'Roll back operations stored in the rollback stack'
    commandGroup = 'System Modification'

    docs = {'just-db'       : (VERBOSE_HELP,
                          'Update db only - Do not modify rest of file system'),
            'replace-files' : ('replace files on system with files from'
                               ' rollback if conflict'),
            'tag-script': ('Output commands to run tag-script to PATH', 'PATH')
           }

    def addParameters(self, argDef):
        ConaryCommand.addParameters(self, argDef)
        argDef["just-db"] = NO_PARAM
        argDef["replace-files"] = NO_PARAM
        argDef["tag-script"] = ONE_PARAM

    def runCommand(self, cfg, argSet, otherArgs):
        kwargs = {}
        if argSet.has_key('replace-files'):
            kwargs['replaceFiles'] = True
            del argSet['replace-files']

        kwargs['tagScript'] = argSet.pop('tag-script', None)
        kwargs['justDatabase'] = argSet.pop('just-db', False)

        kwargs['callback'] = updatecmd.UpdateCallback(cfg)
        if argSet or len(otherArgs) != 3: return self.usage()
        db = openDatabase(cfg.root, cfg.dbPath)
        client = conaryclient.ConaryClient(cfg)
        client.applyRollback(otherArgs[2], **kwargs)
_register(RollbackCommand)


class _AbstractQueryCommand(ConaryCommand):

    docs = {'all-troves'    : '', # Meaning changes based on command
            'buildreqs'     : (VERBOSE_HELP,
                               'Display troves used to satisfy buildreqs'
                               ' of this trove'),
            'deps'          : 'Display trove dependencies',
            'file-deps'     : 'Display dependencies for individual files',
            'file-flavors'  : (VERBOSE_HELP,
                               'Display flavors for individual files'),
            'file-versions' : (VERBOSE_HELP, 'Display file versions'),
            'ids'           : (VERBOSE_HELP,
                               'Display path and file ids for files'),
            'info'          : 'Display detailed trove info',
            'ls'            : 'List files',
            'lsl'           : 'List file details like ls -l',
            'no-pristine'   : optparse.SUPPRESS_HELP,
            'no-recurse'    : (VERBOSE_HELP, 
                               'Force no recursive display of child troves'),
            'path'          : (VERBOSE_HELP, 'Display trove that owns PATH'),
            'recurse'       : (VERBOSE_HELP,
                              'Force recursive display of child troves'),
            'sha1s'         : (VERBOSE_HELP,
                              'Display checksums for original file contents'),
            'signatures'    : (VERBOSE_HELP,
                               'Display any signatures on this trove'),
            'tags'          : (VERBOSE_HELP, 'Display tags for files'),
            'troves'        : (VERBOSE_HELP, 
                               'Display one level of child troves'),
            'trove-flags'   : (VERBOSE_HELP, 'Display trove flags (see man page)'),
            'exact-flavors' : 'Return only troves that match the flavors specified exactly',
            'trove-headers' : (VERBOSE_HELP,
                               'Display current trove name when listing info'
                              ' from multiple troves'),
            'weak-refs'     : optparse.SUPPRESS_HELP,
            'what-provides' : (VERBOSE_HELP, 'Return information about what troves provide a dependency', 'DEP'),
            'what-requires' : (VERBOSE_HELP, 'Return information about what troves require a dependency', 'DEP')
            }




    def addParameters(self, argDef):
        ConaryCommand.addParameters(self, argDef)

        d = {}
        d["ids"] = NO_PARAM
        d["ls"] = NO_PARAM
        d["lsl"] = NO_PARAM
        d["tags"] = NO_PARAM
        d["file-deps"] = NO_PARAM
        d["file-flavors"] = NO_PARAM
        d["file-versions"] = NO_PARAM
        d["sha1s"] = NO_PARAM
        argDef['File Display'] = d

        d = {}
        d["buildreqs"] = NO_PARAM
        d["deps"] = NO_PARAM
        d["info"] = '-i', NO_PARAM
        d["signatures"] = NO_PARAM
        d["trove-flags"] = NO_PARAM
        argDef['Info Display'] = d

        d = {}
        d["all-troves"] = NO_PARAM
        d["recurse"] = NO_PARAM
        d["no-recurse"] = NO_PARAM
        d["troves"] = NO_PARAM
        d["trove-headers"] = NO_PARAM
        d["weak-refs"] = NO_PARAM
        argDef['Child Display'] = d

        d = {}
        d["exact-flavors"] = NO_PARAM
        argDef['Trove Selection'] = d

    def runCommand(self, cfg, argSet, otherArgs):
        raise NotImplementedError

class QueryCommand(_AbstractQueryCommand):

    commands = [ 'query', 'q' ]
    paramHelp = "<pkgname>[=<version>][[flavor]]*"
    help = 'Query the local system database'
    docs = {'all-troves' : 'Display troves that are not installed'}
    commandGroup = 'Information Display'

    def addParameters(self, argDef):
        _AbstractQueryCommand.addParameters(self, argDef)
        d = {}
        d["no-pristine"] = NO_PARAM
        d["path"] = MULT_PARAM
        d["what-provides"] = MULT_PARAM
        argDef['Trove Selection'].update(d)

    def runCommand(self, cfg, argSet, otherArgs):
        kw = {}
        for opt in ('ls', 'lsl', 'ids', 'sha1s', 'tags',
                ('signatures', 'digSigs'), ('buildreqs', 'showBuildReqs'),
                ('file-deps', 'fileDeps'), 
                ('file-flavors', 'fileFlavors'), 
                ('file-versions', 'fileVersions'),
                ('all-troves', 'showAllTroves'),
                ('weak-refs', 'weakRefs'),
                ('troves', 'showTroves'),
                ('trove-headers', 'alwaysDisplayHeaders'),
                ('trove-flags', 'showTroveFlags'),
                ('deps', 'showDeps'), ('exact-flavors', 'exactFlavors'),
                'info'):
            if isinstance(opt, tuple):
                kw[opt[1]] = argSet.pop(opt[0], False)
            else:
                kw[opt] = argSet.pop(opt, False)
        kw['pathList'] = argSet.pop('path', [])
        kw['whatProvidesList'] = argSet.pop('what-provides', [])
        kw['pristine'] = not argSet.pop('no-pristine', False)
        kw['recurse'] = argSet.pop('recurse', None)
        if 'no-recurse' in argSet:
            kw['recurse'] = False
            del argSet['no-recurse']


        db = openDatabase(cfg.root, cfg.dbPath)

        if argSet: return self.usage()

        return query.displayTroves(db, cfg, otherArgs[2:], **kw)
_register(QueryCommand)


class RepQueryCommand(_AbstractQueryCommand):

    commands = [ 'repquery', 'rq' ]
    paramHelp = "<pkgname>[=<version>][[flavor]]*"
    help = 'Query one or more Conary repositories'
    commandGroup = 'Information Display'
    docs = {'affinity'    : ('Use branch and flavor affinity when searching'
                             ' for troves (behave like conary update)'),
            'all-troves'   : 'Display byDefault False troves',
            'all-flavors'  : 'Return all flavors of troves matching the query',
            'all-versions' : 'Return all versions of troves that'
                             ' match the query',
            'available-flavors' : ('Return all flavors that match system flavor'
                                  ' and the query (and affinity if specified)'),
            'best-flavors' : optparse.SUPPRESS_HELP, # default
            'latest-versions': optparse.SUPPRESS_HELP, # default
            'leaves'         : 'Return latest version for each unique flavor',
            'show-removed'   : 'Display troves that have been removed from the repos',
            #'show-redirects' : 'Display redirect troves'
            # turned off for now.
            }

    def addParameters(self, argDef):
        _AbstractQueryCommand.addParameters(self, argDef)
        d = {}
        d["affinity"] = NO_PARAM
        d["all-flavors"] = NO_PARAM
        d["all-versions"] = NO_PARAM
        d["available-flavors"] = NO_PARAM
        d["best-flavors"] = NO_PARAM
        d["latest-versions"] = NO_PARAM
        d["leaves"] = NO_PARAM
        d["path"] = MULT_PARAM
        d["what-provides"] = MULT_PARAM
        d["show-removed"] = NO_PARAM
        #d["show-redirects"] = NO_PARAM
        argDef['Trove Selection'].update(d)

    def runCommand(self, cfg, argSet, otherArgs):
        versionOpts = [argSet.pop(x, False) for x in ['all-versions',
                                                      'latest-versions',
                                                      'leaves']]
        if versionOpts.count(True) > 1:
            log.error('Can only specify one of --all-versions,'
                      '--latest-versions, --leaves')
            sys.exit(1)
        if True in versionOpts:
            versionFilterIdx = versionOpts.index(True)
            versionFilter = [queryrep.VERSION_FILTER_ALL,
                             queryrep.VERSION_FILTER_LATEST,
                             queryrep.VERSION_FILTER_LEAVES][versionFilterIdx]
        else:
            versionFilter = queryrep.VERSION_FILTER_LATEST

        flavorOpts = [argSet.pop(x, False) for x in ['all-flavors',
                                                     'available-flavors',
                                                     'best-flavors',
                                                     'exact-flavors']]

        if flavorOpts.count(True) > 1:
            log.error('only one of --all-flavors, --available-flavors, '
                      ' --best-flavors, --exact-flavors may be'
                      ' specified')
            return 1
        if True in flavorOpts:
            flavorFilterIdx = flavorOpts.index(True)
            flavorFilter = [queryrep.FLAVOR_FILTER_ALL,
                            queryrep.FLAVOR_FILTER_AVAIL,
                            queryrep.FLAVOR_FILTER_BEST,
                            queryrep.FLAVOR_FILTER_EXACT][flavorFilterIdx]
        else: # default
            flavorFilter = queryrep.FLAVOR_FILTER_BEST

        kw = {}
        for opt in ('ls', 'lsl', 'ids', 'sha1s', 'tags',
                ('signatures', 'digSigs'), ('buildreqs', 'showBuildReqs'),
                ('file-deps', 'fileDeps'), 
                ('file-flavors', 'fileFlavors'), 
                ('file-versions', 'fileVersions'),
                ('all-troves', 'showAllTroves'),
                ('weak-refs', 'weakRefs'),
                ('troves', 'showTroves'),
                ('trove-flags', 'showTroveFlags'),
                ('trove-headers', 'alwaysDisplayHeaders'),
                ('affinity', 'useAffinity'),
                ('deps', 'showDeps'), 'info'):
            if isinstance(opt, tuple):
                kw[opt[1]] = argSet.pop(opt[0], False)
            else:
                kw[opt] = argSet.pop(opt, False)

        kw['recurse'] = argSet.pop('recurse', None)
        if 'no-recurse' in argSet:
            kw['recurse'] = False
            del argSet['no-recurse']
        whatProvidesList = argSet.pop('what-provides', [])

        pathList = argSet.pop('path', [])

        if argSet.pop('show-removed', False):
            argSet.pop('show-redirects', False)
            troveTypes = trovesource.TROVE_QUERY_ALL
        #elif argSet.pop('show-redirects', False):
        #    troveTypes = trovesource.TROVE_QUERY_PRESENT
        #else:
        #    troveTypes = trovesource.TROVE_QUERY_NORMAL
        else:
            troveTypes = trovesource.TROVE_QUERY_PRESENT
        kw['troveTypes'] = troveTypes

        troveList = otherArgs[2:]
        queryrep.displayTroves(cfg, troveList, pathList, whatProvidesList,
                               versionFilter, flavorFilter, **kw)
_register(RepQueryCommand)


class RdiffCommand(ConaryCommand):

    commands = [ 'rdiff' ]
    paramHelp = "<pkgname>=<version1>[[flavor1]]--<version2>[[flavor]]"
    help = 'Display differences between troves'
    commandGroup = 'Information Display'
    docs = { 'show-empty'  : 'Show troves even if they did not change',
             'buildreqs'  : 'Show build requirements changes',
             'deps'        : 'Show changes in overall dependencies',
             'ls'          : 'Show file changes',
             'lsl'         : 'Show detailed file changes',
             'tags'        : 'Show changes in file tags',
             'file-versions' : 'Show file versions',
             'file-deps'   : 'Show file dependency changes',
             'file-contents' : 'Show file content changes (non-binary)',
           }

    def addParameters(self, argDef):
        ConaryCommand.addParameters(self, argDef)
        d = {}
        #d["components"] = NO_PARAM
        d["deps"] = NO_PARAM
        d["show-empty"] = NO_PARAM
        d["buildreqs"] = NO_PARAM
        argDef['Trove-related Changes'] = d

        d = {}
        d["ls"] = NO_PARAM
        d["lsl"] = NO_PARAM
        d["tags"] = NO_PARAM
        d["file-versions"] = NO_PARAM
        d["file-deps"] = NO_PARAM
        d["file-contents"] = NO_PARAM
        argDef['File-related Changes'] = d

    def runCommand(self, cfg, argSet, otherArgs):

        args = otherArgs[2:]
        if len(args) != 1:
            return self.usage()

        diffSpec = args[0]
        troveSpec = cmdline.parseChangeList(diffSpec)[0]
        if troveSpec[1][0] is None:
            # Most likely, syntax did not specify <old>--<new>
            return self.usage()

        kw = {}
        kw['fullFlavors'] = cfg.fullFlavors
        kw['fullVersions'] = cfg.fullVersions
        kw['showLabels'] = cfg.showLabels
        kw['showEmptyDiffs'] = argSet.pop('show-empty', False)
        kw['withBuildReqs'] = argSet.pop('buildreqs', False)
        kw['withFileContents'] = argSet.pop('file-contents', False)
        kw['withFileDeps'] = argSet.pop('file-deps', False)
        kw['withFiles'] = argSet.pop('ls', False)
        kw['withFilesStat'] = argSet.pop('lsl', False)
        kw['withFileTags'] = argSet.pop('tags', False)
        kw['withFileVersions'] = argSet.pop('file-versions', False)
        kw['withTroveDeps'] = argSet.pop('deps', False)
        if argSet:
            raise Exception(argSet)

        queryrep.diffTroves(cfg, troveSpec, **kw)
_register(RdiffCommand)


class ShowChangesetCommand(_AbstractQueryCommand):

    commands = [ "showcs", "scs" ]
    paramHelp = "<changeset> <pkgname>[=<version>][[flavor]]*"
    help = 'Display information about a changeset file'
    commandGroup = 'Information Display'
    docs = {'all'                : 'combine many common scs flags',
            'all-troves'         : 'display not-by-default troves', 
            'show-changes'       : ('(for relative changeset) display changes'
                                    ' that the relative changeset contains'),
            'recurse-repository' : (VERBOSE_HELP,
                                    'search the repository for troves not '
                                    'contained in the changeset when recursing')
           }

    def addParameters(self, argDef):
        _AbstractQueryCommand.addParameters(self, argDef)
        d = {}
        argDef['Changeset Display'] = {"all":          NO_PARAM,
                                       "show-changes": NO_PARAM }
        argDef['Child Display']["recurse-repository"] = NO_PARAM

    def runCommand(self, cfg, argSet, otherArgs):
        from conary.repository import changeset
        kw = {}
        # FIXME: organize
        for opt in ('ls', 'lsl', 'ids', 'sha1s', 'tags',
                ('signatures', 'digSigs'), ('buildreqs', 'showBuildReqs'),
                ('file-deps', 'fileDeps'), 
                ('file-flavors', 'fileFlavors'), 
                ('file-versions', 'fileVersions'),
                ('all-troves', 'showAllTroves'),
                ('weak-refs', 'weakRefs'),
                ('troves', 'showTroves'),
                ('trove-flags', 'showTroveFlags'),
                ('trove-headers', 'alwaysDisplayHeaders'),
                ('recurse-repository', 'recurseRepos'),
                'deps', 'info', 'all', ('show-changes', 'showChanges'),
                ('exact-flavors', 'exactFlavors')):
            if isinstance(opt, tuple):
                kw[opt[1]] = argSet.pop(opt[0], False)
            else:
                kw[opt] = argSet.pop(opt, False)


        kw['recurse'] = argSet.pop('recurse', None)
        if 'no-recurse' in argSet:
            kw['recurse'] = False
            del argSet['no-recurse']

        if argSet or len(otherArgs) < 3:
            self.usage()
            return 1

        cspath = otherArgs[2]
        component = None
        if len(otherArgs) > 3:
            component = otherArgs[3:]
        cs = changeset.ChangeSetFromFile(cspath)
        db = database.Database(cfg.root, cfg.dbPath)
        showchangeset.displayChangeSet(db, cs, component, cfg, **kw)
_register(ShowChangesetCommand)


class _UpdateCommand(ConaryCommand):
    paramHelp = "[+][-]<pkgname>[=<version>][[flavor]]* <changeset>*"
    commandGroup = 'System Modification'

    docs = {
        'apply-critical'  : (VERBOSE_HELP, 
                             'apply any critical conary updates and then stop'),
        'from-file'     : 'search changeset(s) for given troves',
        'just-db'       : (VERBOSE_HELP,
                          'Update db only - Do not modify rest of file system'),
        'keep-existing' : 'Install new troves as new, leaving existing troves.',
        'keep-required' : 'Do not erase troves which are needed by troves '
                          'which will remain installed',
        'exact-flavors' : 'Only match troves whose flavors match exactly',
        'info'          : 'Display what update would have done',
        'no-deps'       : 'Do not raise errors due to dependency failures',
        'no-recurse'    : (VERBOSE_HELP, 
                           'Do not install/erase children of specified trove'),
        'no-resolve'    : (VERBOSE_HELP,
                           'Do not attempt to solve dependency problems'),
        'no-conflict-check' : (VERBOSE_HELP,
                               'Ignore potential path conflicts'),
        'no-restart'    : (VERBOSE_HELP,
                           'Do not restart after applying a critical update. '
                           'Requires --root'),
        'recurse'       : optparse.SUPPRESS_HELP,
        'replace-files' : 'Replace existing files if file conflict found '
                          '(equivalent to --replace-managed-files '
                          '--replace-modified-files --replace-unmanaged-files)',
        'replace-config-files':
                          'Replace config files on the system which have '
                          'been changed by something other than conary',
        'replace-managed-files':
                          'Replaces files owned by other troves (including'
                          'other troves which are part of this update)',
        'replace-modified-files':
                          'Replace non-config files on the system which have '
                          'been changed by something other than conary',
        'replace-unmanaged-files':
                          'Replace files on the system which are not owned '
                          'by any trove',
        'resolve'       : 'Add troves to update to solve dependency problems',
        'restart-info'  : optparse.SUPPRESS_HELP,
        'sync-to-parents' : (VERBOSE_HELP,
                            'Install already referenced versions of troves'),
        'tag-script': ('Output commands to run tag-script to PATH', 'PATH'),
        'test'      : 'Run through whole update but do not modify system',
        'update-only' :(VERBOSE_HELP, 'Do not install any new troves'),
    }

    def addParameters(self, argDef):
        ConaryCommand.addParameters(self, argDef)
        d = {}
        d["apply-critical"] = NO_PARAM
        d["from-file"] = MULT_PARAM
        d["just-db"] = NO_PARAM
        d["keep-existing"] = NO_PARAM
        d["keep-journal"] = NO_PARAM            # don't document this
        d["keep-required"] = NO_PARAM
        d["info"] = '-i', NO_PARAM
        d["no-deps"] = NO_PARAM
        d["no-recurse"] = NO_PARAM
        d["no-resolve"] = NO_PARAM
        d["no-restart"] = NO_PARAM
        d["no-conflict-check"] = NO_PARAM
        d["recurse"] = NO_PARAM
        d["replace-files"] = NO_PARAM
        d["replace-config-files"] = NO_PARAM
        d["replace-managed-files"] = NO_PARAM
        d["replace-modified-files"] = NO_PARAM
        d["replace-unmanaged-files"] = NO_PARAM
        d["resolve"] = NO_PARAM
        d["sync-to-parents"] = NO_PARAM
        d["tag-script"] = ONE_PARAM
        d["test"] = NO_PARAM

        d["restart-info"] = ONE_PARAM
        d["exact-flavors"] = NO_PARAM

        argDef['Update Options'] = d

    def runCommand(self, cfg, argSet, otherArgs):
        kwargs = {}

        callback = updatecmd.UpdateCallback(cfg)
        if cfg.quiet:
            callback = callbacks.UpdateCallback()
        if argSet.has_key('quiet'):
            callback = callbacks.UpdateCallback()
            del argSet['quiet']
        kwargs['callback'] = callback

        if argSet.has_key('resolve'):
            cfg.autoResolve = True
            del argSet['resolve']

        noRestart = kwargs['noRestart'] = argSet.pop('no-restart', False)
        if noRestart and cfg.root == '/':
            raise conary.errors.ConaryError(
                "--no-restart has to be used with --root")

        if argSet.has_key('no-resolve'):
            cfg.autoResolve = False
            del argSet['no-resolve']
        if argSet.pop('keep-required', False):
            cfg.keepRequired = True

        kwargs['applyCriticalOnly'] = argSet.pop('apply-critical', False)
        kwargs['replaceManagedFiles'] = argSet.pop('replace-managed-files',
                                                   False)
        kwargs['replaceUnmanagedFiles'] = argSet.pop('replace-unmanaged-files',
                                                     False)
        kwargs['replaceModifiedFiles'] = argSet.pop('replace-modified-files',
                                                    False)
        kwargs['replaceModifiedConfigFiles'] = \
                        argSet.pop('replace-config-files', False)
        if argSet.pop('replace-files', False):
            kwargs['replaceManagedFiles'] = True
            kwargs['replaceUnmanagedFiles'] = True
            kwargs['replaceModifiedFiles'] = True
            kwargs['replaceModifiedConfigFiles'] = True

        kwargs['depCheck'] = not argSet.pop('no-deps', False)
        kwargs['fromFiles'] = argSet.pop('from-file', [])
        kwargs['recurse'] = not argSet.pop('no-recurse', False)
        kwargs['checkPathConflicts'] = \
                                not argSet.pop('no-conflict-check', False)
        kwargs['justDatabase'] = argSet.pop('just-db', False)
        kwargs['info'] = argSet.pop('info', False)
        kwargs['keepExisting'] = argSet.pop('keep-existing', False)
        kwargs['keepJournal'] = argSet.pop('keep-journal', False)
        kwargs['tagScript'] = argSet.pop('tag-script', None)
        kwargs['test'] = argSet.pop('test', False)
        kwargs['sync'] = argSet.pop('sync-to-parents', False)
        kwargs['updateOnly'] = argSet.pop('update-only', False)
        kwargs['restartInfo'] = argSet.pop('restart-info', None)
        kwargs['exactFlavors'] = argSet.pop('exact-flavors', False)

        kwargs['updateByDefault']    = otherArgs[1] != 'erase'
        kwargs['migrate']            = otherArgs[1] == 'migrate'

        #
        kwargs['syncChildren'] = False
        kwargs['syncUpdate'] = False
        if otherArgs[1] == 'sync':
            if argSet.pop('current', False):
                kwargs['syncChildren'] = True
            else:
                kwargs['syncUpdate'] = True
            kwargs['removeNotByDefault'] = argSet.pop('full', False)
        elif otherArgs[1] == 'syncchildren':
            # backwards compatibility.  Don't remove this 
            kwargs['syncChildren'] = True
            kwargs['removeNotByDefault'] = argSet.pop('full', False)

        if kwargs['sync'] and kwargs['fromFiles']:
            log.error("Only one of --sync and --from-file may be used")
            return 1

        if argSet: return self.usage()

        if len(otherArgs) >=3:
            updatecmd.doUpdate(cfg, otherArgs[2:], **kwargs)
        else:
            return self.usage()

class UpdateCommand(_UpdateCommand):
    commands = [ "update" ]
    help = 'Update or install software on the system'
_register(UpdateCommand)


class EraseCommand(_UpdateCommand):
    commands = [ "erase" ]
    help = 'Erase software from the system'

    def addParameters(self, argDef):
        # rename Update Options to Erase Options (CNY-1090)
        _UpdateCommand.addParameters(self, argDef)
        d = argDef['Erase Options'] = argDef.pop('Update Options')
        # --no-restart doesn't make sense in the erase context
        del d['no-restart']

_register(EraseCommand)


class SyncCommand(_UpdateCommand):
    commands = ["syncchildren", "sync"]
    paramHelp = "<pkgname>[=<version>][[flavor]]* <changeset>*"
    help = 'Synchronize software on the system'
    hidden = True
    docs = {
            'current' : 'syncs child troves to this trove w/o updating <pkgname>',
            'full'    : 'also remove children that are non-default',
           }
    def addParameters(self, argDef):
        _UpdateCommand.addParameters(self, argDef)
        sync = argDef.pop('Update Options')
        sync["full"] = NO_PARAM
        sync["current"] = NO_PARAM
        sync["update-only"] = NO_PARAM
        argDef['Sync Options'] = sync

_register(SyncCommand)


class MigrateCommand(_UpdateCommand):

    commands = ["migrate"]
    paramHelp = "<pkgname>[=<version>][[flavor]]*"
    help = 'Migrate the system to a different group'
    hidden = True

    def addParameters(self, argDef):
        _UpdateCommand.addParameters(self, argDef)
        d = argDef.pop('Update Options')
        del d['from-file']
        del d['keep-existing']
        del d['sync-to-parents']
        del d['no-recurse']
        argDef['Migrate Options'] = d
_register(MigrateCommand)


class UpdateAllCommand(_UpdateCommand):

    commands = ['updateall']
    paramHelp = ''
    docs = {'items': ('Display troves that conary updateall will update '
                      'to upgrade your system')}
    help = 'Update all the software on the system'

    def addParameters(self, argDef):
        ConaryCommand.addParameters(self, argDef)
        argDef["items"] = NO_PARAM
        argDef["info"] = '-i', NO_PARAM
        argDef["keep-required"] = NO_PARAM
        argDef["no-conflict-check"] = NO_PARAM
        argDef["no-deps"] = NO_PARAM
        argDef["no-resolve"] = NO_PARAM
        argDef["no-restart"] = NO_PARAM
        argDef["replace-files"] = NO_PARAM
        argDef["resolve"] = NO_PARAM
        argDef["test"] = NO_PARAM
        argDef["restart-info"] = ONE_PARAM
        argDef["apply-critical"] = NO_PARAM

    def runCommand(self, cfg, argSet, otherArgs):
        kwargs = {}

        noRestart = kwargs['noRestart'] = argSet.pop('no-restart', False)
        if noRestart and cfg.root == '/':
            raise conary.errors.ConaryError(
                "--no-restart has to be used with --root")

        if argSet.has_key('info'):
            kwargs['info'] = True
            del argSet['info']

        if argSet.has_key('items'):
            kwargs['showItems'] = True
            del argSet['items']

        if argSet.has_key('no-deps'):
            kwargs['depCheck'] = False
            del argSet['no-deps']

        if argSet.has_key('replace-files'):
            kwargs['replaceFiles'] = True
            del argSet['replace-files']
        if argSet.pop('keep-required', False):
            cfg.keepRequired = True

        kwargs['applyCriticalOnly'] = argSet.pop('apply-critical', False)
        kwargs['restartInfo'] = argSet.pop('restart-info', None)

        kwargs['checkPathConflicts'] = \
                                not argSet.pop('no-conflict-check', False)
        if argSet.has_key('no-resolve'):
            cfg.autoResolve = False
            del argSet['no-resolve']

        if argSet.has_key('resolve'):
            cfg.autoResolve = True
            del argSet['resolve']

        if argSet.has_key('test'):
            kwargs['test'] = argSet['test']
            del argSet['test']

        if argSet: return self.usage()

        if len(otherArgs) == 2:
            return updatecmd.updateAll(cfg, **kwargs)
        else:
            return self.usage()
_register(UpdateAllCommand)


class UpdateConaryCommand(ConaryCommand):
    commands = ['updateconary']
    help = 'Attempt to find a rescue version of conary and install it'
    commandGroup = 'Hidden Commands'
    def runCommand(self, cfg, argSet, otherArgs):
        updatecmd.updateConary(cfg, constants.version)
_register(UpdateConaryCommand)


class VerifyCommand(ConaryCommand):
    commands = ['verify']
    paramHelp = "<pkgname>[=<version>][[flavor]]*"
    help = 'Verify software integrity on the system'
    docs = {'all' : 'verify all troves on system'}
    commandGroup = 'Information Display'

    def addParameters(self, argDef):
        ConaryCommand.addParameters(self, argDef)
        argDef["all"] = NO_PARAM

    def runCommand(self, cfg, argSet, otherArgs):
        db = openDatabase(cfg.root, cfg.dbPath)
        all = argSet.has_key('all')
        if all: del argSet['all']
        if len(otherArgs) < 2 or argSet:
            return self.usage()
        troves = otherArgs[2:]
        verify.verify(troves, db, cfg, all=all)
_register(VerifyCommand)


class ConaryMain(command.MainHandler):
    name = 'conary'
    abstractCommand = ConaryCommand
    configClass = conarycfg.ConaryConfiguration

    version = constants.version
    commandList = _commands
    hobbleShortOpts = True

    def usage(self, rc = 1, showAll=False):
        print 'Conary Software Configuration Management System'
        if not showAll:
            print
            print 'Common Commands (use "conary help" for the full list)'
        return options.MainHandler.usage(self, rc, showAll=showAll)

    def runCommand(self, thisCommand, cfg, argSet, args, debugAll=False):
        sys.excepthook = util.genExcepthook(debug=cfg.debugExceptions,
                                            debugCtrlC=debugAll)

        if not cfg.buildLabel and cfg.installLabelPath:
            cfg.buildLabel = cfg.installLabelPath[0]

        if cfg.installLabelPath:
            cfg.installLabel = cfg.installLabelPath[0]
        else:
            cfg.installLabel = None

        cfg.initializeFlavors()

        profile = False
        if argSet.has_key('profile'):
            import hotshot
            prof = hotshot.Profile('conary.prof')
            prof.start()
            profile = True
            del argSet['profile']

        lsprof = False
        if argSet.has_key('lsprof'):
            import cProfile
            prof = cProfile.Profile()
            prof.enable()
            lsprof = True
            del argSet['lsprof']

        keyCache = openpgpkey.getKeyCache()
        keyCacheCallback = openpgpkey.KeyCacheCallback(cfg.repositoryMap,
                                                       cfg.pubRing[-1])
        keyCache.setCallback(keyCacheCallback)

        rv = options.MainHandler.runCommand(self, thisCommand, cfg,
                                             argSet, args)

        if profile:
            prof.stop()
        if lsprof:
            prof.disable()
            prof.dump_stats('conary.lsprof')
            prof.print_stats()

        if log.errorOccurred():
            return 1

def main(argv=sys.argv):
    try:
        debugAll = '--debug-all' in argv
        if debugAll:
            argv = argv[:]
            argv.remove('--debug-all')
            debuggerException = Exception
        else:
            debuggerException = conary.repository.errors.InternalConaryError

        conaryMain = ConaryMain()
        ccfg = conaryMain.getConfigFile(argv)

        if debugAll:
            ccfg.debugExceptions = True
        # reset the excepthook (using cfg values for exception settings)
        sys.excepthook = util.genExcepthook(debug=ccfg.debugExceptions,
                                            debugCtrlC=debugAll)
        return conaryMain.main(argv, debuggerException, 
                               debugAll=debugAll, cfg=ccfg)
    except IOError, e:
        # allow broken pipe to exit
        if e.errno != errno.EPIPE:
            raise
    except conary.errors.ReexecRequired, e:
        print e
        # a restart of this command has been requested for some 
        # reason.  Exit code will now be the exit code of the redirect.
        if e.execParams is not None:
            args = e.execParams
        else:
            args = sys.argv
        util.massCloseFileDescriptors(3, 252)
        os.execve(sys.argv[0], args, os.environ)
    except debuggerException:
        raise
    except cfgtypes.CfgError, e:
        if log.getVerbosity() == log.DEBUG:
            raise
        log.error(str(e))
    except (conary.repository.errors.ConaryError, 
            openpgpfile.PGPError), e:
        if not str(e):
            raise
        else:
            print >> sys.stderr, str(e)
    except:
        raise
    return 1

if __name__ == "__main__":
    sys.exit(main())
