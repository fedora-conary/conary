#!/usr/bin/python
# -*- mode: python -*-
#
# Copyright (c) 2004-2006 rPath, Inc.
#
# This program is distributed under the terms of the Common Public License,
# version 1.0. A copy of this license should have been distributed with this
# source file in a file called LICENSE. If it is not present, the license
# is always available at http://www.opensource.org/licenses/cpl.php.
#
# This program is distributed in the hope that it will be useful, but
# without any waranty; without even the implied warranty of merchantability
# or fitness for a particular purpose. See the Common Public License for
# full details.
#
"""
The conary main program.
"""

import sys
if sys.version_info < (2, 4):
    print "error: python 2.4 or later is requried"
    sys.exit(1)

if __name__ == "__main__":
    # ondemand importing for conary command line tool 
    # - but don't impose it on others!  They can load it on their own if they
    # want.
    from conary.lib import importer
    importer.install()

#stdlib
import os
import pwd
import xmlrpclib
import errno

from conary.repository import errors
#conary
from conary import callbacks, commit, conarycfg, constants
from conary import cscmd, deps, flavorcfg, query
from conary import queryrep, conaryclient, rollbacks, showchangeset, state
from conary import trove, updatecmd, verify, versions
from conary.lib import cfg,cfgtypes,log, openpgpkey, options, util
from conary.local import database
from conary.conaryclient import cmdline

sys.excepthook = util.genExcepthook(debug=True)

def usage(rc = 1):
    print "usage: conary changeset <pkg>[=[<oldver>--]<newver>]+ <outfile>"
    print "       conary commit       <changeset>"
    print "       conary config"
    print "       conary emerge       <troveName>+"
    print "       conary erase        <pkgname>[=<version>][[flavor]]+"
    print "       conary localcs      <pkgname>[=<version>][[flavor]] <outfile>"
    print "       conary localcommit  <changeset>"
    print "       conary pin          <pkgname>[=<version>][[flavor]]*"
    print "       conary query        <pkgname>[=<version>][[flavor]]*"
    print "       conary remove       <path>+"
    print "       conary repquery     <pkgname>[=<version>][[flavor]]*"
    print "       conary rblist"
    print "       conary rollback     <rollback>"
    print "       conary showcs       <changeset> <trove>[=<version>]*"
    print "       conary syncchildren <pkgname>[=<version>][[flavor]]*"
    print "       conary unpin        <pkgname>[=<version>][[flavor]]*"
    print "       conary update       <pkgname>[=<version>][[flavor]]* <changeset>*"
    print "       conary updateall"
    print "       conary updateconary"
    print "       conary usage"
    print "       conary verify       <pkgname>[=<version>][[flavor]]*"
    print "       conary --version"
    print ""
    print "changeset flags: --exclude-troves <patterns>"
    print "                 --no-recurse"
    print "                 --quiet"
    print ""
    print "commit flags:    --target-branch <branch>"
    print ""
    print "config flags:    --show-passwords --show-contexts"
    print ""
    print 'common flags:    --build-label <label>'
    print '                 --config-file <path>'
    print "                 --components"
    print '                 --config "<item> <value>"'
    print "                 --flavors"
    print "                 --full-versions"
    print '                 --install-label <label>'
    print '                 --interactive'
    print "                 --pubring <path>"
    print "                 --root <root>"
    print "                 --context <context>"
    print ""
    print "Common query/repquery/showcs flags:"
    print ""
    print "      trove display flags"
    print "                 --full-versions"
    print "                 --labels"
    print "                 --flavors"
    print "                 --components"
    print
    print "                 --buildreqs"
    print "                 --deps"
    print "                 --info"
    print "                 --signatures"
    print ""
    print ""
    print "     collection flags"
    print "                 --all-troves"
    print "                 --components"
    print "                 --troves"
    print "                 --trove-flags"
    print "                 --trove-headers"
    print "                 --weak-refs"
    print "                 --recurse"
    print "                 --no-recurse"
    print ""
    print "     file flags (assumes --recurse)"
    print "                 --file-deps"
    print "                 --file-versions"
    print "                 --ids"
    print "                 --ls"
    print "                 --lsl"
    print "                 --sha1s"
    print "                 --tags"
    print
    print ""
    print "     query only flags:"
    print "                 --path <file>"
    print
    print "     repquery flags:"
    print "                 --all-versions"
    print "                 --latest-versions"
    print "                 --leaves"
    print "                 --affinity"
    print ""
    print "                 --all-flavors"
    print "                 --available-flavors"
    print "                 --compatible-flavors"
    print "                 --best-flavors"
    print ""
    print
    print "     showcs flags:"
    print "                 --all"
    print "                 --show-changes"
    print "                 --recurse-repository"
    print
    print "rollback flags:  --replace-files"
    print "syncchildren flags:"
    print "                 --update-only"
    print ""
    print "update/erase/syncchildren flags:"
    print "                 --exclude-troves <patterns>"
    print "                 --from-file <file.ccs>"
    print "                 --info"
    print "                 --just-db"
    print "                 --keep-existing"
    print "                 --no-conflict-check"
    print "                 --no-deps"
    print "                 --no-recurse"
    print "                 --no-resolve"
    print "                 --quiet"
    print "                 --replace-files"
    print "                 --resolve"
    print "                 --sync-to-parents"
    print "                 --test"
    print "updateall flags:"
    print "                 --exclude-troves <patterns>"
    print "                 --info"
    print "                 --no-deps"
    print "                 --no-resolve"
    print "                 --replace-files"
    print "                 --resolve"
    return rc

def openDatabase(root, path):
    return database.Database(root, path)

def realMain(cfg, argv=sys.argv):
    argDef = {}
    cfgMap = {}

    (NO_PARAM,  ONE_PARAM)  = (options.NO_PARAM, options.ONE_PARAM)
    (OPT_PARAM, MULT_PARAM) = (options.OPT_PARAM, options.MULT_PARAM)

    cfgMap["build-label"] = "buildLabel", ONE_PARAM
    cfgMap["exclude-troves"] = "excludeTroves", ONE_PARAM
    cfgMap["trust-threshold"] = "trustThreshold", ONE_PARAM
    cfgMap["pubring"] = "pubRing", ONE_PARAM
    cfgMap["root"] = "root", ONE_PARAM

    cfgMap['interactive'] = 'interactive', NO_PARAM
    cfgMap['full-versions'] = 'fullVersions', NO_PARAM
    cfgMap['labels'] = 'showLabels', NO_PARAM
    cfgMap['flavors'] = 'fullFlavors', NO_PARAM
    cfgMap['components'] = 'showComponents', NO_PARAM


    for name, (cfgName, paramType) in cfgMap.items():
        # if it's a NO_PARAM
        if paramType == NO_PARAM:
            negName = 'no-' + name
            argDef[negName] = paramType
            cfgMap[negName] = (cfgName, paramType)
        argDef[name] = paramType

    argDef["all"] = NO_PARAM
    argDef["all-flavors"] = NO_PARAM
    argDef["all-versions"] = NO_PARAM
    argDef["all-troves"] = NO_PARAM
    argDef["available-flavors"] = NO_PARAM
    argDef["best-flavors"] = NO_PARAM
    argDef["buildreqs"] = NO_PARAM
    argDef["components"] = NO_PARAM
    argDef["compatible-flavors"] = NO_PARAM
    argDef["config"] = MULT_PARAM
    argDef["config-file"] = ONE_PARAM
    argDef["context"] = ONE_PARAM
    argDef["deps"] = NO_PARAM
    argDef["diff"] = NO_PARAM
    argDef["from-file"] = MULT_PARAM
    argDef["file-deps"] = NO_PARAM
    argDef["file-versions"] = NO_PARAM
    argDef["ids"] = NO_PARAM
    argDef["info"] = NO_PARAM
    argDef["install"] = NO_PARAM
    argDef["install-label"] = MULT_PARAM
    argDef["items"] = NO_PARAM
    argDef["just-db"] = NO_PARAM
    argDef["keep-existing"] = NO_PARAM
    argDef["latest-versions"] = NO_PARAM
    argDef["leaves"] = NO_PARAM
    argDef["ls"] = NO_PARAM
    argDef["lsl"] = NO_PARAM
    argDef["affinity"] = NO_PARAM
    argDef["no-deps"] = NO_PARAM
    argDef["no-recurse"] = NO_PARAM
    argDef["resolve"] = NO_PARAM
    argDef["no-resolve"] = NO_PARAM
    argDef["no-conflict-check"] = NO_PARAM
    argDef["path"] = MULT_PARAM
    argDef["no-pristine"] = NO_PARAM
    argDef["profile"] = NO_PARAM
    argDef["quiet"] = NO_PARAM
    argDef["recurse"] = NO_PARAM
    argDef["recurse-repository"] = NO_PARAM
    argDef["replace-files"] = NO_PARAM
    argDef["root"] = ONE_PARAM
    argDef["sha1s"] = NO_PARAM
    argDef["show-changes"] = NO_PARAM
    argDef["show-contexts"] = NO_PARAM
    argDef["show-passwords"] = NO_PARAM
    argDef["signatures"] = NO_PARAM
    argDef["sync-to-parents"] = NO_PARAM
    argDef["tag-script"] = ONE_PARAM
    argDef["tags"] = NO_PARAM
    argDef["target-branch"] = ONE_PARAM
    argDef["test"] = NO_PARAM
    argDef["troves"] = NO_PARAM
    argDef["trove-flags"] = NO_PARAM
    argDef["trove-headers"] = NO_PARAM
    argDef["update-only"] = NO_PARAM
    argDef["weak-refs"] = NO_PARAM
    argDef["version"] = NO_PARAM

    try:
        argSet, otherArgs = options.processArgs(argDef, {}, cfg, usage,
                                                argv=argv)
    except options.OptionError, e:
        print >> sys.stderr, e
        sys.exit(e.val)
    except versions.ParseError, e:
	print >> sys.stderr, e
	sys.exit(1)

    # the user might have specified --config debugExceptions on the commandline
    sys.excepthook = util.genExcepthook(debug=cfg.debugExceptions)

    if argSet.has_key('version'):
        print constants.version
        sys.exit(0)

    context = cfg.context
    if os.path.exists('CONARY'):
        conaryState = state.ConaryStateFromFile('CONARY')
        if conaryState.hasContext():
            context = conaryState.getContext()

    context = os.environ.get('CONARY_CONTEXT', context)
    context = argSet.pop('context', context)


    if context:
        cfg.setContext(context)


    # command line configuration overrides contexts.
    for (arg, (name, paramType)) in cfgMap.items():
        value = argSet.pop(arg, None)
        if value is not None:
            if arg.startswith('no-'):
                value = not value

	    cfg.configLine("%s %s" % (name, value))

    for line in argSet.pop('config', []):
        cfg.configLine(line)

    if not cfg.buildLabel and cfg.installLabelPath:
        cfg.buildLabel = cfg.installLabelPath[0]

    # now set the debug hook using the potentially new cfg.debugExceptions value
    sys.excepthook = util.genExcepthook(debug=cfg.debugExceptions)

    l = []
    for labelStr in argSet.get('install-label', []):
        l.append(versions.Label(labelStr))
    if l:
        cfg.installLabelPath = l
        del argSet['install-label']

    if cfg.installLabelPath:
        cfg.installLabel = cfg.installLabelPath[0]
    
    cfg.initializeFlavors()

    profile = False
    if argSet.has_key('profile'):
	import hotshot
	prof = hotshot.Profile('conary.prof')
	prof.start()
	profile = True
	del argSet['profile']

    keyCache = openpgpkey.getKeyCache()
    keyCacheCallback = openpgpkey.KeyCacheCallback(cfg.repositoryMap,
                                                   cfg.pubRing[-1])
    keyCache.setCallback(keyCacheCallback)

    if (len(otherArgs) < 2):
	return usage()
    elif (otherArgs[1] == "changeset"):
        kwargs = {}
        
        callback = updatecmd.UpdateCallback(cfg)
        if cfg.quiet:
            callback = callbacks.UpdateCallback()
        if argSet.has_key('quiet'):
            callback = callbacks.UpdateCallback()
            del argSet['quiet']
        kwargs['callback'] = callback

        kwargs['recurse'] = not(argSet.has_key('no-recurse'))
        if not kwargs['recurse']:
            del argSet['no-recurse']
            
	if len(otherArgs) < 4 or argSet:
	    return usage()

        outFile = otherArgs[-1]
        del otherArgs[-1]

	cscmd.ChangeSetCommand(cfg, otherArgs[2:], outFile, **kwargs)
    elif (otherArgs[1] == "commit"):
	targetBranch = None
	if argSet.has_key('target-branch'):
	    targetBranch  = argSet['target-branch']
	    del argSet['target-branch']
	if len(otherArgs) < 3: return usage()
	for changeSet in otherArgs[2:]:
	    commit.doCommit(cfg, changeSet, targetBranch)
    elif (otherArgs[1] == "config"):
        
	showPasswords = argSet.pop('show-passwords', False)
	showContexts = argSet.pop('show-contexts', False)
        try:
            prettyPrint = sys.stdout.isatty()
        except AttributeError:
            prettyPrint = False
        cfg.setDisplayOptions(hidePasswords=not showPasswords,
                              showContexts=showContexts,
                              prettyPrint=prettyPrint)
	if argSet: return usage()
	if (len(otherArgs) > 2):
	    return usage()
	else:
	    cfg.display()
    elif (otherArgs[1] == "emerge"):
        # import this late to reduce the dependency set for
        # the main conary command in the common case.  This lets
        # conary run even if, for example, libelf is missing
        from conary.build import cook
	log.setVerbosity(log.INFO)

        if not os.getuid():
            # if we're running as root, switch to the emergeUser
            cookUser = cfg.emergeUser
            if not cookUser:
                log.error('Please set emergeUser config item before emerging')
                return 1
            try:
                info = pwd.getpwnam(cookUser)
            except KeyError:
                log.error("No user named '%s' to emerge with.  Please check "
                          "the 'emergeUser' config item." % cookUser)
                return 1
            if info.pw_dir == '/':
                log.error("The '%s' user's home directory is set to '/'.  "
                          "See http://wiki.conary.com/ConaryConversion for "
                          "assistance."
                          % cookUser)
                return 1
            if info.pw_uid == 0 or info.pw_gid == 0:
                log.error("The '%s' user has root privileges." % cookUser)
                return 1
            cookIds = (info.pw_uid, info.pw_gid)
            # reset the HOME environment variable, and reinterpolate
            # buildPath, lookaside, and logFile configuration variables
            # so that the correct home directory will be used.
            os.environ['HOME'] = info.pw_dir
            for cfgvar in ('buildPath', 'lookaside'):
                unexpanded = cfg[cfgvar]._getUnexpanded()
                cfg.configLine('%s %s' %(cfgvar, unexpanded))
            cfg.configLine('logFile ' +
                ':'.join(x._getUnexpanded() for x in cfg.logFile))
        else:
            cookIds = None

        ignoreDeps = argSet.pop('no-deps', False)
	if argSet: return usage()

        try:
            return cook.cookCommand(cfg, otherArgs[2:], False, {}, emerge = True,
                                    cookIds=cookIds, ignoreDeps=ignoreDeps)
        except cook.CookError, msg:
            log.error(msg)
            return 1
    elif (otherArgs[1] == "localcs"):
	if len(otherArgs) != 4 and len(otherArgs) != 4:
	    return usage()

	name = otherArgs[2]
	outFile = otherArgs[3]

	db = database.Database(cfg.root, cfg.dbPath)
	cscmd.LocalChangeSetCommand(db, cfg, name, outFile)
    elif (otherArgs[1] == "localcommit"):
	if len(otherArgs) < 3: return usage()
	db = database.Database(cfg.root, cfg.dbPath)
	for changeSet in otherArgs[2:]:
	    commit.doLocalCommit(db, changeSet)
    elif (otherArgs[1] == "pin" or otherArgs[1] == "unpin"):
	if argSet: return usage()

        updatecmd.changePins(cfg, otherArgs[2:], pin = otherArgs[1] == "pin")
    elif (otherArgs[1] == "query") or (otherArgs[1] == "q"):
        kw = {}
        for opt in ('ls', 'lsl', 'ids', 'sha1s', 'tags',
                ('signatures', 'digSigs'), ('buildreqs', 'showBuildReqs'),
                ('file-deps', 'fileDeps'), 
                ('file-versions', 'fileVersions'),
                ('all-troves', 'showAllTroves'),
                ('weak-refs', 'weakRefs'),
                ('troves', 'showTroves'),
                ('trove-flags', 'showTroveFlags'),
                'deps', 'info'):
            if isinstance(opt, tuple):
                kw[opt[1]] = argSet.pop(opt[0], False)
            else:
                kw[opt] = argSet.pop(opt, False)
        kw['pathList'] = argSet.pop('path', [])
        kw['pristine'] = not argSet.pop('no-pristine', False)

        kw['recurse'] = argSet.pop('recurse', None)
        if 'no-recurse' in argSet:
            kw['recurse'] = False
            del argset['no-recurse']

	db = openDatabase(cfg.root, cfg.dbPath)

	if argSet: return usage()

        query.displayTroves(db, cfg, otherArgs[2:], **kw)
    elif (otherArgs[1] == "repquery") or (otherArgs[1] == "rq"):
        cfg.requireInstallLabelPath()
        versionOpts = [argSet.pop(x, False) for x in ['all-versions',
                                                      'latest-versions',
                                                      'leaves']]
        if versionOpts.count(True) > 1:
            log.error('Can only specify one of --all-versions,'
                      '--latest-versions, --leaves')
            sys.exit(1)
        if True in versionOpts:
            versionFilterIdx = versionOpts.index(True)
            versionFilter = [queryrep.VERSION_FILTER_ALL,
                             queryrep.VERSION_FILTER_LATEST,
                             queryrep.VERSION_FILTER_LEAVES][versionFilterIdx]
        else:
            versionFilter = queryrep.VERSION_FILTER_LATEST

        flavorOpts = [argSet.pop(x, False) for x in ['all-flavors',
                                                     'available-flavors',
                                                     'best-flavors']]

        if flavorOpts.count(True) > 1:
            log.error('only one of --all-flavors, --available-flavors, '
                      ' --best-flavors may be'
                      ' specified')
            return 1
        if True in flavorOpts:
            flavorFilterIdx = flavorOpts.index(True)
            flavorFilter = [queryrep.FLAVOR_FILTER_ALL,
                            queryrep.FLAVOR_FILTER_AVAIL,
                            queryrep.FLAVOR_FILTER_BEST][flavorFilterIdx]
        else: # default
            flavorFilter = queryrep.FLAVOR_FILTER_BEST

        kw = {}
        for opt in ('ls', 'lsl', 'ids', 'sha1s', 'tags',
                ('signatures', 'digSigs'), ('buildreqs', 'showBuildReqs'),
                ('file-deps', 'fileDeps'), 
                ('file-versions', 'fileVersions'),
                ('all-troves', 'showAllTroves'),
                ('weak-refs', 'weakRefs'),
                ('troves', 'showTroves'),
                ('trove-flags', 'showTroveFlags'),
                ('trove-headers', 'alwaysDisplayHeaders'),
                ('affinity', 'useAffinity'),
                'deps', 'info'):
            if isinstance(opt, tuple):
                kw[opt[1]] = argSet.pop(opt[0], False)
            else:
                kw[opt] = argSet.pop(opt, False)

        kw['recurse'] = argSet.pop('recurse', None)
        if 'no-recurse' in argSet:
            kw['recurse'] = False
            del argset['no-recurse']

        if argSet: return usage()
        troveList = otherArgs[2:]

        queryrep.displayTroves(cfg, troveList, versionFilter, flavorFilter,
                               **kw)
    elif (otherArgs[1] == "rblist"):
	if argSet: return usage()
	db = openDatabase(cfg.root, cfg.dbPath)
	rollbacks.listRollbacks(db, cfg)
    elif (otherArgs[1] == "remove"):
	if len(otherArgs) != 3: return usage()
	if argSet: return usage()
	db = openDatabase(cfg.root, cfg.dbPath)
	fullPath = util.joinPaths(cfg.root, otherArgs[2])
	if os.path.exists(fullPath):
	    os.unlink(fullPath)
	else:
	    log.warning("%s has already been removed", fullPath)
        # this call should move into conaryclient; for now we need
        # this to instantiate the log
        from conary import conaryclient
        client = conaryclient.ConaryClient(cfg)
        log.syslog.command()
        for path in otherArgs[2:]:
            db.removeFile(otherArgs[2])
        log.syslog.commandComplete()
    elif (otherArgs[1] == "rollback"):
        kwargs = {}
	if argSet.has_key('replace-files'):
	    kwargs['replaceFiles'] = True
	    del argSet['replace-files']
        kwargs['callback'] = updatecmd.UpdateCallback(cfg)
	if argSet: return usage()
	db = openDatabase(cfg.root, cfg.dbPath)
	args = [db, cfg] + otherArgs[2:]
	rollbacks.apply(*args, **kwargs)
    elif (otherArgs[1] == "verify"):
	db = openDatabase(cfg.root, cfg.dbPath)
        all = argSet.has_key('all')
	if all: del argSet['all']
        if len(otherArgs) < 2 or argSet:
            return verify.usage()
        troves = otherArgs[2:]
        verify.verify(troves, db, cfg, all=all)
    elif (otherArgs[1] == "showcs" or otherArgs[1] == "scs"):
        from conary.repository import changeset
        kw = {}
        # FIXME: organize
        for opt in ('ls', 'lsl', 'ids', 'sha1s', 'tags',
                ('signatures', 'digSigs'), ('buildreqs', 'showBuildReqs'),
                ('file-deps', 'fileDeps'), 
                ('file-versions', 'fileVersions'),
                ('all-troves', 'showAllTroves'),
                ('weak-refs', 'weakRefs'),
                ('troves', 'showTroves'),
                ('trove-flags', 'showTroveFlags'),
                ('recurse-repository', 'recurseRepos'),
                'deps', 'info', 'all', ('show-changes', 'showChanges')):
            if isinstance(opt, tuple):
                kw[opt[1]] = argSet.pop(opt[0], False)
            else:
                kw[opt] = argSet.pop(opt, False)


        kw['recurse'] = argSet.pop('recurse', None)
        if 'no-recurse' in argSet:
            kw['recurse'] = False
            del argset['no-recurse']

        if argSet or len(otherArgs) < 3:
            showchangeset.usage()
            return 1

        cspath = otherArgs[2]
        component = None
        if len(otherArgs) > 3:
            component = otherArgs[3:]
        cs = changeset.ChangeSetFromFile(cspath)
        db = database.Database(cfg.root, cfg.dbPath)
        showchangeset.displayChangeSet(db, cs, component, cfg, **kw)
    elif otherArgs[1] == "updateconary":
        cfg.requireInstallLabelPath()
        updatecmd.updateConary(cfg, constants.version)
    elif otherArgs[1] in ["update", "erase", "sync", "syncchildren"]:
        cfg.requireInstallLabelPath()
	kwargs = {}

        callback = updatecmd.UpdateCallback(cfg)
        if cfg.quiet:
            callback = callbacks.UpdateCallback()
        if argSet.has_key('quiet'):
            callback = callbacks.UpdateCallback()
            del argSet['quiet']
        kwargs['callback'] = callback

	if argSet.has_key('resolve'):
            cfg.autoResolve = True
	    del argSet['resolve']

	if argSet.has_key('no-resolve'):
            cfg.autoResolve = False
	    del argSet['no-resolve']

        kwargs['replaceFiles'] = argSet.pop('replace-files', False)
        kwargs['depCheck'] = not argSet.pop('no-deps', False)
        kwargs['fromFiles'] = argSet.pop('from-file', [])
        kwargs['recurse'] = not argSet.pop('no-recurse', False)
        kwargs['checkPathConflicts'] = \
                                not argSet.pop('no-conflict-check', False)
        kwargs['justDatabase'] = argSet.pop('just-db', False)
        kwargs['info'] = argSet.pop('info', False)
        kwargs['keepExisting'] = argSet.pop('keep-existing', False)
        kwargs['tagScript'] = argSet.pop('tag-script', None)
        kwargs['test'] = argSet.pop('test', False)
        kwargs['sync'] = argSet.pop('sync-to-parents', False)
        kwargs['updateOnly'] = argSet.pop('update-only', False)
        kwargs['updateByDefault'] = (otherArgs[1] in ("update", "sync",
                                                      "syncchildren"))
        kwargs['syncChildren'] = otherArgs[1] in ('sync', 'syncchildren')

        if kwargs['sync'] and kwargs['fromFiles']:
            log.error("Only one of --sync and --from-file may be used")
            return 1

	if argSet: return usage()

	if len(otherArgs) >=3:
	    updatecmd.doUpdate(cfg, otherArgs[2:], **kwargs)
	else:
	    return usage()
    elif (otherArgs[1] == "updateall"):
        cfg.requireInstallLabelPath()
	kwargs = {}

	if argSet.has_key('info'):
	    kwargs['info'] = True
	    del argSet['info']

	if argSet.has_key('items'):
	    kwargs['showItems'] = True
	    del argSet['items']

	if argSet.has_key('no-deps'):
	    kwargs['depCheck'] = False
	    del argSet['no-deps']

	if argSet.has_key('replace-files'):
	    kwargs['replaceFiles'] = True
	    del argSet['replace-files']

	if argSet.has_key('no-resolve'):
            cfg.autoResolve = False
	    del argSet['no-resolve']

	if argSet.has_key('resolve'):
            cfg.autoResolve = True
	    del argSet['resolve']

	if argSet.has_key('test'):
	    kwargs['test'] = argSet['test']
	    del argSet['test']

	if argSet: return usage()

	if len(otherArgs) == 2:
	    updatecmd.updateAll(cfg, **kwargs)
	else:
	    return usage()
    elif (otherArgs[1] == "return usage"):
	return usage(rc = 0)
    else:
	return usage()

    if profile:
	prof.stop()

    if log.errorOccurred():
	sys.exit(1)

def main(argv=sys.argv):
    from conary.repository import errors
    try:
        if '--skip-default-config' in argv:
            argv = argv[:]
            argv.remove('--skip-default-config')
            ccfg = conarycfg.ConaryConfiguration()
        else:
            ccfg = conarycfg.ConaryConfiguration(readConfigFiles=True)

        # reset the excepthook (using cfg values for exception settings)
        sys.excepthook = util.genExcepthook(debug=ccfg.debugExceptions)
	return realMain(ccfg, argv)
    except IOError, e:
        # allow broken pipe to exit
        if e.errno != errno.EPIPE:
            raise
    except errors.InternalConaryError:
        raise
    except cfgtypes.CfgError, e:
        if log.getVerbosity() == log.DEBUG:
            raise
        log.error(str(e))
    except errors.ConaryError, e:
        if not str(e):
            raise
        else:
            print >> sys.stderr, str(e)
    except:
        raise
    return 1

if __name__ == "__main__":
    sys.exit(main())
