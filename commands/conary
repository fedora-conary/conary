#!/usr/bin/env python2.4
# -*- mode: python -*-
#
# Copyright (c) 2004-2006 rPath, Inc.
#
# This program is distributed under the terms of the Common Public License,
# version 1.0. A copy of this license should have been distributed with this
# source file in a file called LICENSE. If it is not present, the license
# is always available at http://www.opensource.org/licenses/cpl.php.
#
# This program is distributed in the hope that it will be useful, but
# without any warranty; without even the implied warranty of merchantability
# or fitness for a particular purpose. See the Common Public License for
# full details.
#
"""
The conary main program.
"""

import inspect
import sys
if sys.version_info < (2, 4):
    print "error: python 2.4 or later is requried"
    sys.exit(1)

if __name__ == "__main__":
    # ondemand importing for conary command line tool 
    # - but don't impose it on others!  They can load it on their own if they
    # want.
    if '--debug-all' not in sys.argv:
        from conary.lib import importer
        importer.install()

#stdlib
import itertools
import optparse
import os
import pwd
import xmlrpclib
import errno

#conary
import conary
from conary import callbacks, commit, conarycfg, constants
from conary import cscmd, deps, flavorcfg, query, repository
from conary import queryrep, conaryclient, rollbacks, showchangeset, state
from conary import trove, updatecmd, verify, versions
from conary.lib import cfg,cfgtypes,log, openpgpfile, openpgpkey, options, util
from conary.local import database
from conary.conaryclient import cmdline

sys.excepthook = util.genExcepthook(debug=True)

def usage(rc = 1):
    print "usage: conary changeset <pkg>[=[<oldver>--]<newver>]+ <outfile>"
    print "       conary commit       <changeset>"
    print "       conary config"
    print "       conary emerge       <troveName>+"
    print "       conary erase        <pkgname>[=<version>][[flavor]]+"
    print "       conary localcs      <pkgname>[=<version>][[flavor]] <outfile>"
    print "       conary localcommit  <changeset>"
    print "       conary migrate      <pkgname>[=<version>][[flavor]]* <changeset>*"
    print "       conary pin          <pkgname>[=<version>][[flavor]]*"
    print "       conary query        <pkgname>[=<version>][[flavor]]*"
    print "       conary remove       <path>+"
    print "       conary repquery     <pkgname>[=<version>][[flavor]]*"
    print "       conary rblist"
    print "       conary rollback     <rollback>"
    print "       conary showcs       <changeset> <trove>[=<version>]*"
    print "       conary sync         <pkgname>[=<version>][[flavor]]*"
    print "       conary unpin        <pkgname>[=<version>][[flavor]]*"
    print "       conary update       <pkgname>[=<version>][[flavor]]* <changeset>*"
    print "       conary updateall"
    print "       conary updateconary"
    print "       conary usage"
    print "       conary verify       <pkgname>[=<version>][[flavor]]*"
    print "       conary --version"
    print ""
    print "type 'conary <command> --help' for command-specific usage"
    return rc

def openDatabase(root, path):
    return database.Database(root, path)

(NO_PARAM,  ONE_PARAM)  = (options.NO_PARAM, options.ONE_PARAM)
(OPT_PARAM, MULT_PARAM) = (options.OPT_PARAM, options.MULT_PARAM)

_commands = []
def _register(cmd):
    _commands.append(cmd)

class ConaryCommand(options.AbstractCommand):

    paramHelp = ''
    defaultGroup = 'Common Options'

    docs = {'build-label'        : ('Use build label LABEL as default search'
                                    ' loc', 'LABEL'),
            'components'         : ("Do not hide components"),
            'config'             : ("Set config KEY to VALUE", "'KEY VALUE'"),
            'config-file'        : ("Read PATH config file", "PATH"),
            'context'            : "Set the current context",
            'exclude-troves'     : ('Do not install troves matching REGEXP', 
                                    'REGEXP'),
            'install-label'      : ("Set the install label", "LABEL"),
            'interactive'        : ('ask questions before performing actions '
                                    'that change system or repository state'),
            'flavors'            : 'Display complete flavors where applicable',
            'full-versions'      : ('Always display complete version strings'),
            'labels'             : 'Always display labels for versions',
            'profile'            : optparse.SUPPRESS_HELP,
            'lsprof'             : optparse.SUPPRESS_HELP,
            "pubring"            : '',
            'skip-default-config': "Don't read default configs",
            'quiet'              : ('do not display extra information when '
                                    'running'),
            'root'               : 'use conary database at location ROOT',
            'trust-threshold'    : ('Set trust threshold', 'INT')
            }


    def addParameters(self, argDef):
        d = {}
        d["config"] = '-c', MULT_PARAM
        d["config-file"] = MULT_PARAM
        d["context"] = ONE_PARAM
        d["install-label"] = MULT_PARAM
        d["profile"] = NO_PARAM
        d["lsprof"] = NO_PARAM
        d["skip-default-config"] = NO_PARAM
        argDef[self.defaultGroup] = d

    def addConfigOptions(self, cfgMap, argDef):
        cfgMap["build-label"] = "buildLabel", ONE_PARAM
        cfgMap["exclude-troves"] = "excludeTroves", ONE_PARAM
        cfgMap["trust-threshold"] = "trustThreshold", ONE_PARAM
        cfgMap["pubring"] = "pubRing", ONE_PARAM
        cfgMap["root"] = "root", ONE_PARAM, '-r'
        cfgMap["quiet"] = "quiet", NO_PARAM

        cfgMap['interactive'] = 'interactive', NO_PARAM,
        cfgMap['full-versions'] = 'fullVersions', NO_PARAM
        cfgMap['labels'] = 'showLabels', NO_PARAM,
        cfgMap['flavors'] = 'fullFlavors', NO_PARAM,
        cfgMap['components'] = 'showComponents', NO_PARAM
        options.AbstractCommand.addConfigOptions(self, cfgMap, argDef)

    def setContext(self, cfg, argSet):
        context = cfg.context
        if os.access('CONARY', os.R_OK):
            conaryState = state.ConaryStateFromFile('CONARY', parseSource=False)
            if conaryState.hasContext():
                context = conaryState.getContext()

        context = os.environ.get('CONARY_CONTEXT', context)
        context = argSet.pop('context', context)

        if context:
            cfg.setContext(context)

    def processConfigOptions(self, cfg, cfgMap, argSet):
        self.setContext(cfg, argSet)
        options.AbstractCommand.processConfigOptions(self, cfg, cfgMap, argSet)

        l = []
        for labelStr in argSet.get('install-label', []):
            l.append(versions.Label(labelStr))
        if l:
            cfg.installLabelPath = l
            del argSet['install-label']


class ChangeSetCommand(ConaryCommand):
    commands = ['changeset', 'cs' ]
    paramHelp = '''\
<pkg>[=[<oldver>--]<newver>]+ <outfile>

Creates a changeset with the specified troves and stores it in <outfile>'''

    docs = {'no-recurse' : "Don't include child troves in changeset"}

    def addParameters(self, argDef):
        ConaryCommand.addParameters(self, argDef)
        argDef['no-recurse'] = NO_PARAM

    def runCommand(self, cfg, argSet, otherArgs):
        kwargs = {}

        callback = updatecmd.UpdateCallback(cfg)
        if cfg.quiet:
            callback = callbacks.UpdateCallback()
        if argSet.has_key('quiet'):
            callback = callbacks.UpdateCallback()
            del argSet['quiet']
        kwargs['callback'] = callback

        kwargs['recurse'] = not(argSet.has_key('no-recurse'))
        if not kwargs['recurse']:
            del argSet['no-recurse']

        if len(otherArgs) < 4 or argSet:
            return self.usage()

        outFile = otherArgs[-1]
        del otherArgs[-1]

        cscmd.ChangeSetCommand(cfg, otherArgs[2:], outFile, **kwargs)
_register(ChangeSetCommand)

class ConfigCommand(ConaryCommand):
    commands = ['config']

    docs = {'show-contexts'  : 'display contexts as well as current config',
            'show-passwords' : 'do not mask passwords'}

    def addParameters(self, argDef):
        ConaryCommand.addParameters(self, argDef)
        argDef["show-contexts"] = NO_PARAM
        argDef["show-passwords"] = NO_PARAM

    def runCommand(self, cfg, argSet, otherArgs):
        showPasswords = argSet.pop('show-passwords', False)
        showContexts = argSet.pop('show-contexts', False)
        try:
            prettyPrint = sys.stdout.isatty()
        except AttributeError:
            prettyPrint = False
        cfg.setDisplayOptions(hidePasswords=not showPasswords,
                              showContexts=showContexts,
                              prettyPrint=prettyPrint)
        if argSet: return self.usage()
        if (len(otherArgs) > 2):
            return self.usage()
        else:
            cfg.display()
_register(ConfigCommand)


class CommitCommand(ConaryCommand):
    commands = ['commit']
    paramHelp = "<changeset>"

    docs = {'target-branch' : ('commit to branch BRANCH', 'BRANCH')}

    def addParameters(self, argDef):
        ConaryCommand.addParameters(self, argDef)
        argDef["target-branch"] = ONE_PARAM

    def runCommand(self, cfg, argSet, otherArgs):
        targetBranch = None
        if argSet.has_key('target-branch'):
            targetBranch  = argSet['target-branch']
            del argSet['target-branch']
        if len(otherArgs) < 3: return self.usage()
        for changeSet in otherArgs[2:]:
            commit.doCommit(cfg, changeSet, targetBranch)
_register(CommitCommand)

class EmergeCommand(ConaryCommand):
    commands = ['emerge']
    paramHelp = "<troveName>+"

    docs = {'no-deps' : 'Do not check to see if buildreqs are installed' }

    def addParameters(self, argDef):
        ConaryCommand.addParameters(self, argDef)
        argDef["no-deps"] = NO_PARAM

    def runCommand(self, cfg, argSet, otherArgs):
        # import this late to reduce the dependency set for
        # the main conary command in the common case.  This lets
        # conary run even if, for example, libelf is missing
        from conary.build import cook
        log.setVerbosity(log.INFO)

        if not os.getuid():
            # if we're running as root, switch to the emergeUser
            cookUser = cfg.emergeUser
            if not cookUser:
                log.error('Please set emergeUser config item before emerging')
                return 1
            try:
                info = pwd.getpwnam(cookUser)
            except KeyError:
                log.error("No user named '%s' to emerge with.  Please check "
                          "the 'emergeUser' config item." % cookUser)
                return 1
            if info.pw_dir == '/':
                log.error("The '%s' user's home directory is set to '/'.  "
                          "See http://wiki.rpath.com/wiki/Conary:Conversion for "
                          "assistance."
                          % cookUser)
                return 1
            if info.pw_uid == 0 or info.pw_gid == 0:
                log.error("The '%s' user has root privileges." % cookUser)
                return 1
            cookIds = (info.pw_uid, info.pw_gid)
            # reset the HOME environment variable, and reinterpolate
            # buildPath, lookaside, and logFile configuration variables
            # so that the correct home directory will be used.
            os.environ['HOME'] = info.pw_dir
            for cfgvar in ('buildPath', 'lookaside'):
                unexpanded = cfg[cfgvar]._getUnexpanded()
                cfg.configLine('%s %s' %(cfgvar, unexpanded))
            cfg.configLine('logFile ' +
                ':'.join(x._getUnexpanded() for x in cfg.logFile))
        else:
            cookIds = None

        ignoreDeps = argSet.pop('no-deps', False)
        if argSet: return self.usage()

        try:
            return cook.cookCommand(cfg, otherArgs[2:], False, {},
                                    emerge = True, cookIds=cookIds,
                                    ignoreDeps=ignoreDeps)
        except cook.CookError, msg:
            log.error(msg)
            return 1
_register(EmergeCommand)


class LocalChangeSetCommand(ConaryCommand):
    commands = ['localcs']
    paramHelp = "<pkgname>[=<version>][[flavor]] <outfile>"

    def runCommand(self, cfg, argSet, otherArgs):
        if len(otherArgs) != 4 and len(otherArgs) != 4:
            return self.usage()

        name = otherArgs[2]
        outFile = otherArgs[3]

        db = database.Database(cfg.root, cfg.dbPath)
        cscmd.LocalChangeSetCommand(db, cfg, name, outFile)
_register(LocalChangeSetCommand)


class LocalCommitCommand(ConaryCommand):
    commands = ['localcommit']
    paramHelp = "<changeset>"

    def runCommand(self, cfg, argSet, otherArgs):
        if len(otherArgs) < 3: return self.usage()
        db = database.Database(cfg.root, cfg.dbPath)
        for changeSet in otherArgs[2:]:
            commit.doLocalCommit(db, changeSet)
_register(LocalCommitCommand)


class PinCommand(ConaryCommand):
    commands = ['pin', 'unpin']
    paramHelp = "<pkgname>[=<version>][[flavor]]*"

    def runCommand(self, cfg, argSet, otherArgs):
        if argSet: return self.usage()
        updatecmd.changePins(cfg, otherArgs[2:], pin = otherArgs[1] == "pin")
_register(PinCommand)


class RemoveCommand(ConaryCommand):
    commands = ['remove']
    paramHelp = "<path>+"

    def runCommand(self, cfg, argSet, otherArgs):
        if len(otherArgs) < 3: return self.usage()
        if argSet: return self.usage()

        client = conaryclient.ConaryClient(cfg)
        db = client.db
        log.syslog.command()

        rc = 0

        pathList = []

        for path in otherArgs[2:]:
            if not path:
                log.error("remove cannot handle an empty path")
                return 1

            if path[0] == '/':
                fullPath = util.joinPaths(cfg.root, path)
            else:
                fullPath = os.path.realpath(path)
                if fullPath.startswith(cfg.root) and cfg.root != '/':
                    # fix up the path to be relative to the root dir
                    path = fullPath[len(cfg.root):]
                    if path[0] != '/':
                        # the root ended with a /
                        path = '/' + fullPath

            pathList.append((fullPath, path))

        try:
            db.removeFiles([ x[1] for x in pathList ])
        except conary.errors.DatabaseError, e:
            log.error(str(e))
            return 1
        except OSError, e:
            log.error("cannot remove %s: %s" % (fullPath, e.strerror))
            return 1

        for (fullPath, path) in pathList:
            try:
                try:
                    os.unlink(fullPath)
                except OSError, e:
                    if e.errno != errno.ENOENT:
                        raise

                    log.warning("%s has already been removed from the "
                                "filesystem", fullPath)
            except OSError, e:
                log.error("cannot remove %s: %s" % (fullPath, e.strerror))
                rc = 1
            except Exception, e:
                log.error("cannot remove %s: %s" % (fullPath, str(e)))
                rc = 1

        log.syslog.commandComplete()
_register(RemoveCommand)


class ListRollbackCommand(ConaryCommand):
    commands = ['rblist']

    def runCommand(self, cfg, argSet, otherArgs):
        if argSet or len(otherArgs) > 2: return self.usage()
        db = openDatabase(cfg.root, cfg.dbPath)
        rollbacks.listRollbacks(db, cfg)
_register(ListRollbackCommand)

class RollbackCommand(ConaryCommand):
    commands = ['rollback']
    paramHelp = "<rollback>"

    docs = {'replace-files' : ('replace files on system with files from'
                               ' rollback if conflict'),
            'tag-script': ('Output commands to run tag-script to PATH', 'PATH')
           }

    def addParameters(self, argDef):
        ConaryCommand.addParameters(self, argDef)
        argDef["replace-files"] = NO_PARAM
        argDef["tag-script"] = ONE_PARAM

    def runCommand(self, cfg, argSet, otherArgs):
        kwargs = {}
        if argSet.has_key('replace-files'):
            kwargs['replaceFiles'] = True
            del argSet['replace-files']

        kwargs['tagScript'] = argSet.pop('tag-script', None)

        kwargs['callback'] = updatecmd.UpdateCallback(cfg)
        if argSet or len(otherArgs) != 3: return self.usage()
        db = openDatabase(cfg.root, cfg.dbPath)
        args = [db, cfg] + otherArgs[2:]
        rollbacks.apply(db, cfg, otherArgs[2], **kwargs)
_register(RollbackCommand)


class _AbstractQueryCommand(ConaryCommand):

    docs = {'all-troves'    : '', # Meaning changes based on command
            'buildreqs'     : ('Display troves used to satisfy buildreqs'
                               ' of this trove'),
            'deps'          : 'Display trove dependencies',
            'file-deps'     : 'Display dependencies for individual files',
            'file-versions' : 'Display file versions',
            'ids'           : 'Display path and file ids for files',
            'info'          : 'Display detailed trove info',
            'ls'            : 'List files',
            'lsl'           : 'List file details like ls -l',
            'no-pristine'   : optparse.SUPPRESS_HELP,
            'no-recurse'    : 'Force no recursive display of child troves',
            'path'          : 'Display trove that owns PATH',
            'recurse'       : 'Force recursive display of child troves',
            'sha1s'         : 'Display checksums for original file contents',
            'signatures'    : 'Display any signatures on this trove',
            'tags'          : 'Display tags for files',
            'troves'        : 'Display one level of child troves',
            'trove-flags'   : 'Display trove flags (see man page)',
            'trove-headers' : 'Display current trove name when listing info'
                              ' from multiple troves',
            'weak-refs'     : optparse.SUPPRESS_HELP,
            'what-provides' : ('Return information about what troves provide a dependency', 'DEP'),
            'what-requires' : ('Return information about what troves require a dependency', 'DEP')
            }




    def addParameters(self, argDef):
        ConaryCommand.addParameters(self, argDef)

        d = {}
        d["ids"] = NO_PARAM
        d["ls"] = NO_PARAM
        d["lsl"] = NO_PARAM
        d["tags"] = NO_PARAM
        d["file-deps"] = NO_PARAM
        d["file-versions"] = NO_PARAM
        d["sha1s"] = NO_PARAM
        argDef['File Display'] = d

        d = {}
        d["buildreqs"] = NO_PARAM
        d["deps"] = NO_PARAM
        d["info"] = '-i', NO_PARAM
        d["signatures"] = NO_PARAM
        d["trove-flags"] = NO_PARAM
        argDef['Info Display'] = d

        d = {}
        d["all-troves"] = NO_PARAM
        d["recurse"] = NO_PARAM
        d["no-recurse"] = NO_PARAM
        d["troves"] = NO_PARAM
        d["trove-headers"] = NO_PARAM
        d["weak-refs"] = NO_PARAM
        argDef['Child Display'] = d

    def runCommand(self, cfg, argSet, otherArgs):
        raise NotImplementedError

class QueryCommand(_AbstractQueryCommand):

    commands = [ 'query', 'q' ]
    paramHelp = "<pkgname>[=<version>][[flavor]]*"

    docs = {'all-troves' : 'Display troves that are not installed'}

    def addParameters(self, argDef):
        _AbstractQueryCommand.addParameters(self, argDef)
        d = {}
        d["no-pristine"] = NO_PARAM
        d["path"] = MULT_PARAM
        d["what-provides"] = MULT_PARAM
        argDef['Trove Selection'] = d

    def runCommand(self, cfg, argSet, otherArgs):
        kw = {}
        for opt in ('ls', 'lsl', 'ids', 'sha1s', 'tags',
                ('signatures', 'digSigs'), ('buildreqs', 'showBuildReqs'),
                ('file-deps', 'fileDeps'), 
                ('file-versions', 'fileVersions'),
                ('all-troves', 'showAllTroves'),
                ('weak-refs', 'weakRefs'),
                ('troves', 'showTroves'),
                ('trove-headers', 'alwaysDisplayHeaders'),
                ('trove-flags', 'showTroveFlags'),
                ('deps', 'showDeps'), 'info'):
            if isinstance(opt, tuple):
                kw[opt[1]] = argSet.pop(opt[0], False)
            else:
                kw[opt] = argSet.pop(opt, False)
        kw['pathList'] = argSet.pop('path', [])
        kw['whatProvidesList'] = argSet.pop('what-provides', [])
        kw['pristine'] = not argSet.pop('no-pristine', False)
        kw['recurse'] = argSet.pop('recurse', None)
        if 'no-recurse' in argSet:
            kw['recurse'] = False
            del argSet['no-recurse']


        db = openDatabase(cfg.root, cfg.dbPath)

        if argSet: return self.usage()

        return query.displayTroves(db, cfg, otherArgs[2:], **kw)
_register(QueryCommand)


class RepQueryCommand(_AbstractQueryCommand):

    commands = [ 'repquery', 'rq' ]
    paramHelp = "<pkgname>[=<version>][[flavor]]*"

    docs = { 'affinity'    : ('Use branch and flavor affinity when searching'
                             ' for troves (behave like conary update)'),
            'all-troves'   : 'Display byDefault False troves',
            'all-flavors'  : 'Return all flavors of troves matching the query',
            'all-versions' : 'Return all versions of troves that'
                             ' match the query',
            'available-flavors' : ('Return all flavors that match system flavor'
                                  ' and the query (and affinity if specified)'),
            'best-flavors' : optparse.SUPPRESS_HELP, # default
            'latest-versions': optparse.SUPPRESS_HELP, # default
            'leaves'         : 'Return latest version for each unique flavor'}


    def addParameters(self, argDef):
        _AbstractQueryCommand.addParameters(self, argDef)
        d = {}
        d["affinity"] = NO_PARAM
        d["all-flavors"] = NO_PARAM
        d["all-versions"] = NO_PARAM
        d["available-flavors"] = NO_PARAM
        d["best-flavors"] = NO_PARAM
        d["latest-versions"] = NO_PARAM
        d["leaves"] = NO_PARAM
        d["what-provides"] = MULT_PARAM
        argDef['Trove Selection'] = d

    def runCommand(self, cfg, argSet, otherArgs):
        cfg.requireInstallLabelPath()
        versionOpts = [argSet.pop(x, False) for x in ['all-versions',
                                                      'latest-versions',
                                                      'leaves']]
        if versionOpts.count(True) > 1:
            log.error('Can only specify one of --all-versions,'
                      '--latest-versions, --leaves')
            sys.exit(1)
        if True in versionOpts:
            versionFilterIdx = versionOpts.index(True)
            versionFilter = [queryrep.VERSION_FILTER_ALL,
                             queryrep.VERSION_FILTER_LATEST,
                             queryrep.VERSION_FILTER_LEAVES][versionFilterIdx]
        else:
            versionFilter = queryrep.VERSION_FILTER_LATEST

        flavorOpts = [argSet.pop(x, False) for x in ['all-flavors',
                                                     'available-flavors',
                                                     'best-flavors']]

        if flavorOpts.count(True) > 1:
            log.error('only one of --all-flavors, --available-flavors, '
                      ' --best-flavors may be'
                      ' specified')
            return 1
        if True in flavorOpts:
            flavorFilterIdx = flavorOpts.index(True)
            flavorFilter = [queryrep.FLAVOR_FILTER_ALL,
                            queryrep.FLAVOR_FILTER_AVAIL,
                            queryrep.FLAVOR_FILTER_BEST][flavorFilterIdx]
        else: # default
            flavorFilter = queryrep.FLAVOR_FILTER_BEST

        kw = {}
        for opt in ('ls', 'lsl', 'ids', 'sha1s', 'tags',
                ('signatures', 'digSigs'), ('buildreqs', 'showBuildReqs'),
                ('file-deps', 'fileDeps'), 
                ('file-versions', 'fileVersions'),
                ('all-troves', 'showAllTroves'),
                ('weak-refs', 'weakRefs'),
                ('troves', 'showTroves'),
                ('trove-flags', 'showTroveFlags'),
                ('trove-headers', 'alwaysDisplayHeaders'),
                ('affinity', 'useAffinity'),
                ('deps', 'showDeps'), 'info'):
            if isinstance(opt, tuple):
                kw[opt[1]] = argSet.pop(opt[0], False)
            else:
                kw[opt] = argSet.pop(opt, False)

        kw['recurse'] = argSet.pop('recurse', None)
        if 'no-recurse' in argSet:
            kw['recurse'] = False
            del argSet['no-recurse']
        whatProvidesList = argSet.pop('what-provides', [])

        if argSet: return self.usage()
        troveList = otherArgs[2:]

        queryrep.displayTroves(cfg, troveList, whatProvidesList, versionFilter,
                               flavorFilter, **kw)
_register(RepQueryCommand)

class ShowChangesetCommand(_AbstractQueryCommand):

    commands = [ "showcs", "scs" ]
    paramHelp = "<changeset> <pkgname>[=<version>][[flavor]]*"

    docs = {'all'                : 'combine many common scs flags',
            'all-troves'         : 'display not-by-default troves', 
            'show-changes'       : ('(for relative changeset) display changes'
                                    'that the relative changeset contains'),
            'recurse-repository' : ('search the repository for troves not '
                                    'contained in the changeset when recursing')
           }

    def addParameters(self, argDef):
        _AbstractQueryCommand.addParameters(self, argDef)
        d = {}
        argDef['Changeset Display'] = {"all":          NO_PARAM,
                                       "show-changes": NO_PARAM }
        argDef['Child Display']["recurse-repository"] = NO_PARAM

    def runCommand(self, cfg, argSet, otherArgs):
        from conary.repository import changeset
        kw = {}
        # FIXME: organize
        for opt in ('ls', 'lsl', 'ids', 'sha1s', 'tags',
                ('signatures', 'digSigs'), ('buildreqs', 'showBuildReqs'),
                ('file-deps', 'fileDeps'), 
                ('file-versions', 'fileVersions'),
                ('all-troves', 'showAllTroves'),
                ('weak-refs', 'weakRefs'),
                ('troves', 'showTroves'),
                ('trove-flags', 'showTroveFlags'),
                ('trove-headers', 'alwaysDisplayHeaders'),
                ('recurse-repository', 'recurseRepos'),
                'deps', 'info', 'all', ('show-changes', 'showChanges')):
            if isinstance(opt, tuple):
                kw[opt[1]] = argSet.pop(opt[0], False)
            else:
                kw[opt] = argSet.pop(opt, False)


        kw['recurse'] = argSet.pop('recurse', None)
        if 'no-recurse' in argSet:
            kw['recurse'] = False
            del argSet['no-recurse']

        if argSet or len(otherArgs) < 3:
            self.usage()
            return 1

        cspath = otherArgs[2]
        component = None
        if len(otherArgs) > 3:
            component = otherArgs[3:]
        cs = changeset.ChangeSetFromFile(cspath)
        db = database.Database(cfg.root, cfg.dbPath)
        showchangeset.displayChangeSet(db, cs, component, cfg, **kw)
_register(ShowChangesetCommand)


class UpdateCommand(ConaryCommand):

    commands = ["update", "erase" ]
    paramHelp = "<pkgname>[=<version>][[flavor]]* <changeset>*"

    docs = {
        'apply-critical'  : 'apply any critical conary updates and then stop',
        'from-file'     : 'search changeset(s) for given troves',
        'just-db'       : 'Update db only - Do not modify rest of file system',
        'keep-existing' : 'Install new troves as new, leaving existing troves.',
        'keep-required' : 'Do not erase troves which are needed by troves '
                          'which will remain installed',
        'info'          : 'Display what update would have done',
        'no-deps'       : 'Do not raise errors due to dependency failures',
        'no-recurse'    : 'Do not install/erase children of specified trove',
        'no-resolve'    : 'Do not attempt to solve dependency problems',
        'no-conflict-check' : 'Ignore potential path conflicts',
        'recurse'       : optparse.SUPPRESS_HELP,
        'replace-files' : 'Replace existing files if file conflict found',
        'resolve'       : 'Add troves to update to solve dependency problems',
        'restart-info'  : optparse.SUPPRESS_HELP,
        'sync-to-parents' : 'Install already referenced versions of troves',
        'tag-script': ('Output commands to run tag-script to PATH', 'PATH'),
        'test'      : 'Run through whole update but do not modify system',
        'update-only' : 'Do not install any new troves',
    }

    def addParameters(self, argDef):
        ConaryCommand.addParameters(self, argDef)
        d = {}
        d["apply-critical"] = NO_PARAM
        d["from-file"] = MULT_PARAM
        d["just-db"] = NO_PARAM
        d["keep-existing"] = NO_PARAM
        d["keep-required"] = NO_PARAM
        d["info"] = '-i', NO_PARAM
        d["no-deps"] = NO_PARAM
        d["no-recurse"] = NO_PARAM
        d["no-resolve"] = NO_PARAM
        d["no-conflict-check"] = NO_PARAM
        d["recurse"] = NO_PARAM
        d["replace-files"] = NO_PARAM
        d["resolve"] = NO_PARAM
        d["sync-to-parents"] = NO_PARAM
        d["tag-script"] = ONE_PARAM
        d["test"] = NO_PARAM

        d["restart-info"] = ONE_PARAM

        argDef['Update Options'] = d

    def runCommand(self, cfg, argSet, otherArgs):
        # NOTE: this code path is used by sync and migrate as well.
        cfg.requireInstallLabelPath()
        kwargs = {}

        callback = updatecmd.UpdateCallback(cfg)
        if cfg.quiet:
            callback = callbacks.UpdateCallback()
        if argSet.has_key('quiet'):
            callback = callbacks.UpdateCallback()
            del argSet['quiet']
        kwargs['callback'] = callback

        if argSet.has_key('resolve'):
            cfg.autoResolve = True
            del argSet['resolve']

        if argSet.has_key('no-resolve'):
            cfg.autoResolve = False
            del argSet['no-resolve']

        kwargs['applyCriticalOnly'] = argSet.pop('apply-critical', False)
        kwargs['replaceFiles'] = argSet.pop('replace-files', False)
        kwargs['depCheck'] = not argSet.pop('no-deps', False)
        kwargs['fromFiles'] = argSet.pop('from-file', [])
        kwargs['recurse'] = not argSet.pop('no-recurse', False)
        kwargs['checkPathConflicts'] = \
                                not argSet.pop('no-conflict-check', False)
        kwargs['justDatabase'] = argSet.pop('just-db', False)
        kwargs['info'] = argSet.pop('info', False)
        kwargs['keepExisting'] = argSet.pop('keep-existing', False)
        kwargs['keepRequired'] = argSet.pop('keep-required', False)
        kwargs['tagScript'] = argSet.pop('tag-script', None)
        kwargs['test'] = argSet.pop('test', False)
        kwargs['sync'] = argSet.pop('sync-to-parents', False)
        kwargs['updateOnly'] = argSet.pop('update-only', False)
        kwargs['restartInfo'] = argSet.pop('restart-info', None)

        kwargs['updateByDefault']    = otherArgs[1] != 'erase'
        kwargs['migrate']            = otherArgs[1] == 'migrate'

        #
        kwargs['syncChildren'] = False
        kwargs['syncUpdate'] = False
        if otherArgs[1] == 'sync':
            if argSet.pop('current', False):
                kwargs['syncChildren'] = True
            else:
                kwargs['syncUpdate'] = True
            kwargs['removeNotByDefault'] = argSet.pop('full', False)
        elif otherArgs[1] == 'syncchildren':
            # backwards compatibility.  Don't remove this 
            kwargs['syncChildren'] = True
            kwargs['removeNotByDefault'] = argSet.pop('full', False)

        if kwargs['sync'] and kwargs['fromFiles']:
            log.error("Only one of --sync and --from-file may be used")
            return 1

        if argSet: return self.usage()

        if len(otherArgs) >=3:
            updatecmd.doUpdate(cfg, otherArgs[2:], **kwargs)
        else:
            return self.usage()
_register(UpdateCommand)

class SyncCommand(UpdateCommand):

    commands = ["sync", "syncchildren"]
    paramHelp = "<pkgname>[=<version>][[flavor]]* <changeset>*"

    docs = {
            'current' : 'syncs child troves to this trove w/o updating <pkgname>',
            'full'    : 'also remove children that are non-default',
           }
    def addParameters(self, argDef):
        UpdateCommand.addParameters(self, argDef)
        sync = argDef.pop('Update Options')
        sync["full"] = NO_PARAM
        sync["current"] = NO_PARAM
        sync["update-only"] = NO_PARAM
        argDef['Sync Options'] = sync

_register(SyncCommand)

class MigrateCommand(UpdateCommand):

    commands = ["migrate"]
    paramHelp = "<pkgname>[=<version>][[flavor]]*"

    def addParameters(self, argDef):
        UpdateCommand.addParameters(self, argDef)
        d = argDef.pop('Update Options')
        del d['from-file']
        del d['keep-existing']
        del d['sync-to-parents']
        del d['no-recurse']
        argDef['Migrate Options'] = d
_register(MigrateCommand)


class UpdateAllCommand(UpdateCommand):

    commands = ['updateall']
    docs = {'items': ('Display troves that conary updateall will update '
                      'to upgrade your system')}

    def addParameters(self, argDef):
        ConaryCommand.addParameters(self, argDef)
        argDef["items"] = NO_PARAM
        argDef["info"] = '-i', NO_PARAM
        argDef["keep-required"] = NO_PARAM
        argDef["no-conflict-check"] = NO_PARAM
        argDef["no-deps"] = NO_PARAM
        argDef["no-resolve"] = NO_PARAM
        argDef["replace-files"] = NO_PARAM
        argDef["resolve"] = NO_PARAM
        argDef["test"] = NO_PARAM
        argDef["restart-info"] = ONE_PARAM
        argDef["apply-critical"] = NO_PARAM

    def runCommand(self, cfg, argSet, otherArgs):
        cfg.requireInstallLabelPath()
        kwargs = {}

        if argSet.has_key('info'):
            kwargs['info'] = True
            del argSet['info']

        if argSet.has_key('items'):
            kwargs['showItems'] = True
            del argSet['items']

        if argSet.has_key('no-deps'):
            kwargs['depCheck'] = False
            del argSet['no-deps']

        if argSet.has_key('replace-files'):
            kwargs['replaceFiles'] = True
            del argSet['replace-files']

        kwargs['applyCriticalOnly'] = argSet.pop('apply-critical', False)
        kwargs['restartInfo'] = argSet.pop('restart-info', None)
        kwargs['keepRequired'] = argSet.pop('keep-required', False)

        kwargs['checkPathConflicts'] = \
                                not argSet.pop('no-conflict-check', False)
        if argSet.has_key('no-resolve'):
            cfg.autoResolve = False
            del argSet['no-resolve']

        if argSet.has_key('resolve'):
            cfg.autoResolve = True
            del argSet['resolve']

        if argSet.has_key('test'):
            kwargs['test'] = argSet['test']
            del argSet['test']

        if argSet: return self.usage()

        if len(otherArgs) == 2:
            return updatecmd.updateAll(cfg, **kwargs)
        else:
            return self.usage()
_register(UpdateAllCommand)


class UpdateConaryCommand(ConaryCommand):
    commands = ['updateconary']

    def runCommand(self, cfg, argSet, otherArgs):
        cfg.requireInstallLabelPath()
        updatecmd.updateConary(cfg, constants.version)
_register(UpdateConaryCommand)


class VerifyCommand(ConaryCommand):
    commands = ['verify']
    paramHelp = "<pkgname>[=<version>][[flavor]]*"

    docs = {'all' : 'verify all troves on system'}

    def addParameters(self, argDef):
        ConaryCommand.addParameters(self, argDef)
        argDef["all"] = NO_PARAM

    def runCommand(self, cfg, argSet, otherArgs):
        db = openDatabase(cfg.root, cfg.dbPath)
        all = argSet.has_key('all')
        if all: del argSet['all']
        if len(otherArgs) < 2 or argSet:
            return self.usage()
        troves = otherArgs[2:]
        verify.verify(troves, db, cfg, all=all)
_register(VerifyCommand)

class ConaryMain(options.MainHandler):
    name = 'conary'
    abstractCommand = ConaryCommand
    configClass = conarycfg.ConaryConfiguration

    version = constants.version
    commandList = _commands
    hobbleShortOpts = True

    def usage(self, rc = 1):
        return usage(rc)

    def runCommand(self, thisCommand, cfg, argSet, args, debugAll=False):
        sys.excepthook = util.genExcepthook(debug=cfg.debugExceptions,
                                            debugCtrlC=debugAll)

        if not cfg.buildLabel and cfg.installLabelPath:
            cfg.buildLabel = cfg.installLabelPath[0]

        if cfg.installLabelPath:
            cfg.installLabel = cfg.installLabelPath[0]

        cfg.initializeFlavors()

        profile = False
        if argSet.has_key('profile'):
            import hotshot
            prof = hotshot.Profile('conary.prof')
            prof.start()
            profile = True
            del argSet['profile']

        lsprof = False
        if argSet.has_key('lsprof'):
            import cProfile
            prof = cProfile.Profile()
            prof.enable()
            lsprof = True
            del argSet['lsprof']

        keyCache = openpgpkey.getKeyCache()
        keyCacheCallback = openpgpkey.KeyCacheCallback(cfg.repositoryMap,
                                                       cfg.pubRing[-1])
        keyCache.setCallback(keyCacheCallback)

        rv = options.MainHandler.runCommand(self, thisCommand, cfg,
                                             argSet, args)

        if profile:
            prof.stop()
        if lsprof:
            prof.disable()
            prof.dump_stats('conary.lsprof')
            prof.print_stats()

        if log.errorOccurred():
            return 1

def main(argv=sys.argv):
    try:
        debugAll = '--debug-all' in argv
        if debugAll:
            argv = argv[:]
            argv.remove('--debug-all')
            debuggerException = Exception
        else:
            debuggerException = conary.repository.errors.InternalConaryError

        conaryMain = ConaryMain()
        ccfg = conaryMain.getConfigFile(argv)

        if debugAll:
            ccfg.debugExceptions = True
        # reset the excepthook (using cfg values for exception settings)
        sys.excepthook = util.genExcepthook(debug=ccfg.debugExceptions,
                                            debugCtrlC=debugAll)
        return conaryMain.main(argv, debuggerException, 
                               debugAll=debugAll, cfg=ccfg)
    except IOError, e:
        # allow broken pipe to exit
        if e.errno != errno.EPIPE:
            raise
    except conary.errors.ReexecRequired, e:
        print e
        # a restart of this command has been requested for some 
        # reason.  Exit code will now be the exit code of the redirect.
        if e.execParams is not None:
            args = e.execParams
        else:
            args = sys.argv
        os.execve(sys.argv[0], args, os.environ)
    except debuggerException:
        raise
    except cfgtypes.CfgError, e:
        if log.getVerbosity() == log.DEBUG:
            raise
        log.error(str(e))
    except (conary.repository.errors.ConaryError, 
            openpgpfile.PGPError), e:
        if not str(e):
            raise
        else:
            print >> sys.stderr, str(e)
    except:
        raise
    return 1

if __name__ == "__main__":
    sys.exit(main())
