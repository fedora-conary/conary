#!/usr/bin/env python2.4
# -*- python -*-
#
# Copyright (c) 2004-2006 rPath, Inc.
#
# This program is distributed under the terms of the Common Public License,
# version 1.0. A copy of this license should have been distributed with this
# source file in a file called LICENSE. If it is not present, the license
# is always available at http://www.rpath.com/permanent/licenses/CPL-1.0.
#
# This program is distributed in the hope that it will be useful, but
# without any warranty; without even the implied warranty of merchantability
# or fitness for a particular purpose. See the Common Public License for
# full details.
#

import cPickle
import gobject
import gtk
import hotshot.stats
import sys
import pango

SHOW_CALLERS = 'Parent function'
SHOW_CALLEES = 'Child function'

class ProfileStat(gobject.GObject):
    func = None
    cc = 0
    nc = 0
    tt = 0.0
    ct = 0.0
    callers = None
    callees = None
gobject.type_register(ProfileStat)

class Caller(gobject.GObject):
    func = None
    nc = 0
    cc = 0
    tt = 0
    ct = 0
gobject.type_register(Caller)

def compare(a, b):
    if a < b:
        return -1
    if a > b:
        return 1
    return 0

def format_float(x):
    return "%.3f" % x

def set_func(tree, cell, model, iter):
    info = model.get_value(iter, 0)
    cell.set_property('text', '%s:%d(%s)' % info.func)

def sort_func(model, iter1, iter2):
    info1 = model.get_value(iter1, 0)
    info2 = model.get_value(iter2, 0)
    return compare(info1.func, info2.func)

def set_num_calls(tree, cell, model, iter):
    info = model.get_value(iter, 0)
    if info.nc != info.cc:
        try:
            c = '%d/%d' %(info.nc, info.cc)
        except:
            import epdb;epdb.st()
    else:
        c = str(info.nc)
    cell.set_property('text', c)

def sort_num_calls(model, iter1, iter2):
    info1 = model.get_value(iter1, 0)
    info2 = model.get_value(iter2, 0)
    return compare(info1.nc, info2.nc)

def set_t_time(tree, cell, model, iter):
    info = model.get_value(iter, 0)
    cell.set_property('text', format_float(info.tt))

def sort_t_time(model, iter1, iter2):
    info1 = model.get_value(iter1, 0)
    info2 = model.get_value(iter2, 0)
    return compare(info1.tt, info2.tt)

def set_t_time_per_call(tree, cell, model, iter):
    info = model.get_value(iter, 0)
    if info.nc != 0:
        cell.set_property('text', format_float(info.tt/info.nc))
    else:
        cell.set_property('text', '')

def sort_t_time_per_call(model, iter1, iter2):
    info1 = model.get_value(iter1, 0)
    info2 = model.get_value(iter2, 0)
    t1 = 0
    if info1.nc != 0:
        t1 = info1.tt/info1.nc
    t2 = 0
    if info2.nc != 0:
        t2 = info2.tt/info2.nc
    return compare(t1, t2)

def set_c_time(tree, cell, model, iter):
    info = model.get_value(iter, 0)
    cell.set_property('text', format_float(info.ct))

def sort_c_time(model, iter1, iter2):
    info1 = model.get_value(iter1, 0)
    info2 = model.get_value(iter2, 0)
    return compare(info1.ct, info2.ct)

def set_c_time_per_call(tree, cell, model, iter):
    info = model.get_value(iter, 0)
    if info.cc != 0:
        cell.set_property('text', format_float(info.ct/info.cc))
    else:
        cell.set_property('text', '')

def sort_c_time_per_call(model, iter1, iter2):
    info1 = model.get_value(iter1, 0)
    info2 = model.get_value(iter2, 0)
    t1 = 0
    if info1.cc != 0:
        t1 = info1.ct/info1.cc
    t2 = 0
    if info2.cc != 0:
        t2 = info2.ct/info2.cc
    return compare(t1, t2)

def setup_tree_view(treeview, model, cols):
    renderer = gtk.CellRendererText()
    for title, set, sort in cols:
        col = treeview.insert_column_with_data_func(-1, title, renderer, set)
        col -= 1
        column = treeview.get_column(col)
        model.set_sort_func(col, sort)
        column.set_sort_column_id(col)

class StatWindow(gtk.Window):
    def __init__(self, filename):
        gtk.Window.__init__(self, gtk.WINDOW_TOPLEVEL)
        self.disable_callbacks = False
        self.current_display = SHOW_CALLERS
        self.set_title('Profile viewer: %s' %filename)
        self.connect('destroy', lambda *x: gtk.main_quit())
        self.set_default_size(800, 400)
        self.source_window = SourceWindow()
        mainpane = gtk.VPaned()
        mainpane.pack1(self.source_window)
        pane = gtk.VPaned()
        mainpane.pack2(pane)

        self.funcstore = gtk.ListStore(ProfileStat)
        self.funcview = gtk.TreeView(self.funcstore)

        self.funcselection = self.funcview.get_selection()
        self.funcselection.connect("changed", self._display_callers_or_callees)
        self.funcview.connect("key_press_event", self.button_press)

        cols = (('Num calls', set_num_calls, sort_num_calls),
                ('Total Time', set_t_time, sort_t_time),
                ('Per call', set_t_time_per_call, sort_t_time_per_call),
                ('Cumulative time', set_c_time, sort_c_time),
                ('Per call', set_c_time_per_call, sort_c_time_per_call),
                ('Function', set_func, sort_func))
        setup_tree_view(self.funcview, self.funcstore, cols)
        # set to total time, decending
        self.funcstore.set_sort_column_id(1, gtk.SORT_DESCENDING)

        sw = gtk.ScrolledWindow()
        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        sw.set_size_request(150, 150)
        sw.add(self.funcview)
        pane.pack1(sw, True, False)

        self.callerstore = gtk.ListStore(Caller)
        self.callerview = gtk.TreeView(self.callerstore)

        selection = self.callerview.get_selection()
        selection.connect("changed", self.display_function)

        cols = (('Num calls', set_num_calls, sort_num_calls),
                ('Total time', set_t_time, sort_t_time),
                ('Cumulative time', set_c_time, sort_c_time),
                ('Parent function', set_func, sort_func))
        setup_tree_view(self.callerview, self.callerstore, cols)
        # set to number of calls, decending
        self.callerstore.set_sort_column_id(0, gtk.SORT_DESCENDING)

        sw = gtk.ScrolledWindow()
        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        sw.set_size_request(-1, 150)
        sw.add(self.callerview)
        pane.pack2(sw, False, True)

        self.add(mainpane)

    def button_press(self, obj, event):
        selection = obj.get_selection()
        if event.keyval == ord('c'):
            self.display_children(selection)
        elif event.keyval == ord('p'):
            self.display_callers(selection)
        elif event.keyval == ord('s'):
            self.display_source(selection)

    def display_source(self, selection):
        model, iter = selection.get_selected()
        if not iter:
            return
        info = model.get_value(iter, 0)
        self.source_window.show()

    def enable_callbacks(self):
        self.disable_callbacks = False

    def _display_callers_or_callees(self, selection, what=None):
        if self.disable_callbacks:
            return
        self.disable_callbacks = True
        gobject.idle_add(self.enable_callbacks)

        model, iter = selection.get_selected()
        if not iter:
            return

        # show the relevant source
        info = model.get_value(iter, 0)
        path, lineno, func = info.func
        self.source_window.load_source(path, lineno)

        self.callerstore.clear()

        if not what:
            what = self.current_display

        if what == SHOW_CALLERS:
            callinfo = info.callers
        elif what == SHOW_CALLEES:
            callinfo = info.callees
        else:
            raise RuntimeError('"what" must be SHOW_CALLERS or SHOW_CALLEES')
        self.current_display = what

        for func, nc in callinfo.iteritems():
            caller = Caller()
            caller.func = func
            if type(nc) == tuple:
                caller.nc = nc[0]
                caller.cc = nc[1]
                caller.tt = nc[2]
                caller.ct = nc[3]
            else:
                caller.nc = nc
                caller.cc = nc
                caller.tt = stats[func][2]
                caller.ct = stats[func][3]
            iter = self.callerstore.append()
            self.callerstore.set(iter, 0, caller)
            self.callerview.get_column(2).set_title(what)
            self.callerview.get_column(3).set_title(what)

    def display_callers(self, selection):
        self._display_callers_or_callees(selection, SHOW_CALLERS)

    def display_children(self, selection):
        self._display_callers_or_callees(selection, SHOW_CALLEES)

    def display_function(self, selection):
        model, iter = selection.get_selected()
        if not iter:
            return
        selection.unselect_all()
        caller = model.get_value(iter, 0)
        iter = self.funcstore.get_iter_first()
        while iter:
            stat = self.funcstore.get_value(iter, 0)
            if stat.func == caller.func:
                self.funcselection.select_iter(iter)
                path = self.funcstore.get_path(iter)
                col = self.funcview.get_column(0)
                self.funcview.scroll_to_cell(path, col, True, 0.5, 0.5)
                self.funcview.set_cursor(path, col, False)
                break
            iter = self.funcstore.iter_next(iter)

    def populate(self, stats):
        callees = {}
        for func, (cc, nc, tt, ct, callers) in stats.iteritems():
            callees.setdefault(func, {})
            for caller, num in callers.iteritems():
                d = callees.setdefault(caller, {})
                d[func] = num

        for func, (cc, nc, tt, ct, callers) in stats.iteritems():
            stat = ProfileStat()
            stat.func = func
            stat.cc = cc
            stat.nc = nc
            stat.tt = tt
            stat.ct = ct
            stat.callers = callers
            stat.callees = callees[func]
            iter = self.funcstore.append()
            self.funcstore.set(iter, 0, stat)

class SourceWindow(gtk.ScrolledWindow):
    def __init__(self):
        self.last_file = None
        self.source_buffer = None
        self.start = None
        self.end = None
        gtk.ScrolledWindow.__init__(self)
        self.set_size_request(700, 400)
        view = self.view = gtk.TextView()
        view.set_property('editable', False)
        self.add(view)

    def idle_load_source(self, args):
        path, lineno = args

        if path != self.last_file:
            self.last_file = path
            source_buffer = SourceBuffer()
            self.source_buffer = source_buffer
            try:
                f = open(path, 'r')
            except IOError:
                return

            source_buffer.insert_source(f.read())
            f.close()
        else:
            source_buffer = self.source_buffer
            if self.start and self.end:
                source_buffer.get_buffer().remove_tag_by_name('current',
                                                              self.start,
                                                              self.end)

        buffer = source_buffer.get_buffer()
        self.view.set_buffer(buffer)

        # buffer lines start at 0
        iter = buffer.get_iter_at_line(lineno - 1)
        buffer.place_cursor(iter)
        mark = buffer.create_mark(None, iter)
        self.view.scroll_to_mark(buffer.get_insert(), 0, True, 0.5, 0.5)
        start = iter.copy()
        end = iter.copy()
        end.forward_chars(start.get_bytes_in_line())
        buffer.apply_tag_by_name('current', start, end)
        self.start = start
        self.end = end

    def load_source(self, path, lineno=0):
        gobject.idle_add(self.idle_load_source, (path, lineno))

class SourceBuffer:
    def __init__(self):
        buffer = self.buffer = gtk.TextBuffer(None)
        tag = buffer.create_tag('source')
        tag.set_property('font', 'monospace')
        tag.set_property('pixels_above_lines', 0)
        tag.set_property('pixels_below_lines', 0)
        buffer.create_tag('current', background='#aaaaff')
        buffer.create_tag('lineno', foreground='#00b000')

    def get_buffer(self):
        return self.buffer

    def insert_source(self, data):
        buffer = self.buffer
        iter = buffer.get_iter_at_offset(0)
        data = data.split('\n')
        for num, line in enumerate(data):
            while '\t' in line:
                line = line.replace('\t', '        ')
            lineno = '%5d ' %(num +1)
            buffer.insert_with_tags_by_name(iter, lineno, 'lineno')
            buffer.insert_with_tags_by_name(iter, line, 'source')
            buffer.insert_with_tags_by_name(iter, '\n', 'source')

if __name__ == '__main__':
    if len(sys.argv) != 2:
        print "usage: %s profile-file" %sys.argv[0]
        sys.exit(1)

    filename = sys.argv[1]
    if ".pickle" in filename:
        f = open(filename)
        stats = cPickle.load(f).stats
    elif filename.endswith('.lsprof'):
        import marshal
        f = open(filename)
        stats = marshal.load(f)
    else:
        stats = hotshot.stats.load(filename).stats

    app = StatWindow(filename)
    app.populate(stats)
    app.show_all()
    gtk.main()
