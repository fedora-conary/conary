#!/usr/bin/python2.4
# -*- mode: python -*-
#
# Copyright (c) 2005 Specifix, Inc.
#
# This program is distributed under the terms of the Common Public License,
# version 1.0. A copy of this license should have been distributed with this
# source file in a file called LICENSE. If it is not present, the license
# is always available at http://www.opensource.org/licenses/cpl.php.
#
# This program is distributed in the hope that it will be useful, but
# without any waranty; without even the implied warranty of merchantability
# or fitness for a particular purpose. See the Common Public License for
# full details.
#

"""
checkcontents examines the database and data store on a system to see
if there are missing contents.  If the --repair flag is given, the contents
will be downloaded from the appropriate repositories and restored
"""

import os
import sys
if os.path.dirname(sys.argv[0]) != ".":
    if sys.argv[0][0] == "/":
	fullPath = os.path.dirname(sys.argv[0])
    else:
	fullPath = os.getcwd() + "/" + os.path.dirname(sys.argv[0])
else:
    fullPath = os.getcwd()

sys.path.append(os.path.dirname(fullPath))

import conarycfg
import datastore
import deps
import files
from lib import options, sha1helper, util
from repository import netclient
import sqlite3
from local import sqldb

def usage():
    print 'usage: %s [--root rootpath] [--repair]' %sys.argv[0]

def getTroveInfo(db, instanceId):
    "return troveName, version, and flavor for a given db's instanceId"
    cu = db.db.cursor()
    cu.execute('SELECT troveName, flavor FROM DBInstances '
               '  JOIN DBFlavors on DBInstances.flavorId = DBFlavors.flavorId '
               'WHERE instanceId=?', (instanceId))
    troveName, frozenFlavor = cu.next()
    flavor = deps.deps.ThawDependencySet(frozenFlavor)
    version = db.instances.getVersion(instanceId)
    return troveName, version, flavor

def main(argv):
    sys.excepthook = util.genExcepthook()
    cfg = conarycfg.ConaryConfiguration()

    argDef = {}
    argDef['repair'] = options.NO_PARAM

    cfgMap = {'root': 'root'}
    try:
        argSet, otherArgs = options.processArgs(argDef, cfgMap, cfg, usage,
                                                argv=argv)
    except options.OptionError, s:
        print s
        sys.exit(1)
    
    repair = argSet.has_key('repair')

    dbPath = os.sep.join((cfg.root, cfg.dbPath, 'conarydb'))
    db = sqldb.Database(dbPath)

    contentsPath = os.sep.join((cfg.root, cfg.dbPath, 'contents'))
    contentsStore = datastore.DataStore(contentsPath)

    # list of needed (fileId, fileVersion) tuples
    neededFiles = []
    # list of needed contents sha1 hashes
    neededSha1s = []

    # loop over all the files in the database
    cu = db.db.cursor()
    cu.execute('SELECT streamId, pathId, path, versionId, instanceId, stream '
               'FROM DBTroveFiles')
    for streamId, pathId, path, versionId, instanceId, stream in cu:
        f = files.ThawFile(stream, pathId)
        # if it's a config file, check to make sure that it is in the
        # data store
        if f.flags.isConfig():
            h = sha1helper.sha1ToString(f.contents.sha1())
            if not contentsStore.hasFile(h):
                # uh-oh, we're missing contents. print an error and make note
                troveName, troveVersion, flavor = getTroveInfo(db, instanceId)
                fileVersion = db.versionTable.getBareId(versionId)
                print troveName, troveVersion.asString(), path, \
                      '(sha1: %s)' %h, 'missing from data store'
                neededFiles.append((f.fileId(), fileVersion))
                neededSha1s.append(h)

    if repair:
        # set up a network client using the repositoryMap - hopefully
        # it has servers for any version string that's in the database
        repos = netclient.NetworkRepositoryClient(cfg.repositoryMap)
        # request the contents we're missing
        contents = repos.getFileContents(neededFiles)
        # loop over the contents we got back and the list of sha1s
        # we're missing
        for fileObj, h in zip(contents, neededSha1s):
            # save the contents we got in the datastore
            contentsStore.addFile(fileObj.get(), h)
            # double check that the contents sha1 matches what we expect
            h2 = sha1helper.sha1String(contentsStore.openFile(h).read())
            h2 = sha1helper.sha1ToString(h2)
            assert(h == h2)
                
if __name__ == '__main__':
    main(sys.argv)

